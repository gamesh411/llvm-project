/Users/efulop/llvm-project/clang/include/clang/StaticAnalyzer/Checkers/EmbeddedDSLFramework.h:
    1|       |// Embedded DSL Framework for Temporal Logic-Based Static Analysis
    2|       |// This framework provides a domain-specific language for defining temporal
    3|       |// logic properties and automatically generating monitor automatons for
    4|       |// violation detection.
    5|       |
    6|       |#ifndef LLVM_CLANG_STATICANALYZER_CHECKERS_EMBEDDEDDSLFRAMEWORK_H
    7|       |#define LLVM_CLANG_STATICANALYZER_CHECKERS_EMBEDDEDDSLFRAMEWORK_H
    8|       |
    9|       |#include "clang/AST/Decl.h"
   10|       |#include "clang/AST/DeclBase.h"
   11|       |#include "clang/AST/Expr.h"
   12|       |#include "clang/AST/Type.h"
   13|       |#include "clang/Basic/SourceLocation.h"
   14|       |#include "clang/StaticAnalyzer/Core/BugReporter/BugReporter.h"
   15|       |#include "clang/StaticAnalyzer/Core/BugReporter/BugType.h"
   16|       |#include "clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h"
   17|       |#include "clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h"
   18|       |#include "clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h"
   19|       |#include "clang/StaticAnalyzer/Core/PathSensitive/SymbolManager.h"
   20|       |#include "llvm/ADT/StringRef.h"
   21|       |#include "llvm/Support/raw_ostream.h"
   22|       |#include <functional>
   23|       |#include <map>
   24|       |#include <memory>
   25|       |#include <set>
   26|       |#include <string>
   27|       |#include <vector>
   28|       |#include <cstdlib>
   29|       |
   30|       |// Generic symbol state for any temporal property
   31|       |enum class SymbolState {
   32|       |  Uninitialized, // Symbol not yet processed
   33|       |  Active,        // Symbol is in active state
   34|       |  Inactive,      // Symbol is in inactive state
   35|       |  Violated,      // Symbol violates the property
   36|       |  Invalid        // Invalid state
   37|       |};
   38|       |
   39|       |// Generic symbol usage context in temporal formulas
   40|       |enum class SymbolContext {
   41|       |  Creation,    // Symbol is created (return value, acquisition)
   42|       |  Destruction, // Symbol is destroyed (parameter, release)
   43|       |  Validation,  // Symbol is validated (condition check)
   44|       |  Temporal,    // Symbol appears in temporal operators (F, G, U, etc.)
   45|       |  CrossContext // Symbol appears in multiple contexts
   46|       |};
   47|       |
   48|       |// State trait registrations
   49|       |REGISTER_MAP_WITH_PROGRAMSTATE(GenericSymbolMap, clang::ento::SymbolRef,
   50|       |                               std::string)
   51|       |REGISTER_MAP_WITH_PROGRAMSTATE(SymbolStates, clang::ento::SymbolRef,
   52|       |                               SymbolState)
   53|       |REGISTER_MAP_WITH_PROGRAMSTATE(CrossContextSymbolMap, std::string,
   54|       |                               clang::ento::SymbolRef)
   55|       |// Symbols that should report leak at function end (to place diag at closing brace)
   56|       |REGISTER_SET_WITH_PROGRAMSTATE(PendingLeakSet, clang::ento::SymbolRef)
   57|       |// Symbols that became dead along a path; finalize at EndFunction for brace location
   58|       |REGISTER_SET_WITH_PROGRAMSTATE(FunctionEndLeakSet, clang::ento::SymbolRef)
   59|       |// Map tracked symbols to the last known bound region for nullness checks
   60|       |REGISTER_MAP_WITH_PROGRAMSTATE(SymbolToRegionMap, clang::ento::SymbolRef,
   61|       |                               const clang::ento::MemRegion *)
   62|       |
   63|       |namespace llvm {
   64|       |template <> struct FoldingSetTrait<std::string> {
   65|      0|  static void Profile(const std::string &X, FoldingSetNodeID &ID) {
   66|      0|    ID.AddString(X);
   67|      0|  }
   68|       |};
   69|       |} // namespace llvm
   70|       |
   71|       |namespace clang {
   72|       |namespace ento {
   73|       |namespace dsl {
   74|       |// Debug helper (opt-in via environment variable EDSL_DEBUG)
   75|     30|static inline bool edslDebugEnabled() {
   76|     30|  static int Initialized = 0;
   77|     30|  static bool Enabled = false;
   78|     30|  if (!Initialized) {
   79|      1|    Enabled = std::getenv("EDSL_DEBUG") != nullptr;
   80|      1|    Initialized = 1;
   81|      1|  }
   82|     30|  return Enabled;
   83|     30|}
  ------------------
  | Unexecuted instantiation: EmbeddedDSLMonitorChecker.cpp:_ZN5clang4ento3dslL16edslDebugEnabledEv
  ------------------
  | EmbeddedDSLSpot.cpp:_ZN5clang4ento3dslL16edslDebugEnabledEv:
  |   75|     30|static inline bool edslDebugEnabled() {
  |   76|     30|  static int Initialized = 0;
  |   77|     30|  static bool Enabled = false;
  |   78|     30|  if (!Initialized) {
  |   79|      1|    Enabled = std::getenv("EDSL_DEBUG") != nullptr;
  |   80|      1|    Initialized = 1;
  |   81|      1|  }
  |   82|     30|  return Enabled;
  |   83|     30|}
  ------------------
   84|       |
   85|       |
   86|       |// Forward declarations
   87|       |class LTLFormulaNode;
   88|       |class LTLState;
   89|       |class LTLAutomaton;
   90|       |class LTLParser;
   91|       |class AutomaticSymbolTracker;
   92|       |
   93|       |// LTL formula node types
   94|       |enum class LTLNodeType {
   95|       |  Atomic,     // Atomic proposition (function call, variable)
   96|       |  And,        // Logical AND
   97|       |  Or,         // Logical OR
   98|       |  Not,        // Logical NOT
   99|       |  Implies,    // Logical implication
  100|       |  Globally,   // Always (G)
  101|       |  Eventually, // Eventually (F)
  102|       |  Next,       // Next (X)
  103|       |  Until,      // Until (U)
  104|       |  Release     // Release (R)
  105|       |};
  106|       |
  107|       |// Symbol binding types for DSL
  108|       |enum class BindingType {
  109|       |  ReturnValue,    // Function return value
  110|       |  FirstParameter, // First function parameter
  111|       |  NthParameter,   // Nth function parameter
  112|       |  Variable        // General variable
  113|       |};
  114|       |
  115|       |// Symbol binding information
  116|       |struct SymbolBinding {
  117|       |  BindingType Type;
  118|       |  std::string SymbolName;
  119|       |  int ParameterIndex; // For NthParameter
  120|       |
  121|       |  SymbolBinding(BindingType t, const std::string &name, int index = 0)
  122|     18|      : Type(t), SymbolName(name), ParameterIndex(index) {}
  123|       |};
  124|       |
  125|       |// Symbol tracking information derived from formula analysis
  126|       |struct SymbolTrackingInfo {
  127|       |  std::string SymbolName;
  128|       |  std::set<SymbolContext> Contexts;
  129|       |  std::set<std::string> Functions; // Functions that operate on this symbol
  130|       |  bool IsTemporallyTracked;        // Appears in temporal operators
  131|       |  bool IsCrossContext;             // Appears in multiple contexts
  132|       |  std::string
  133|       |      PrimaryFunction; // Main function for this symbol (e.g., "malloc" for "x")
  134|       |
  135|       |  SymbolTrackingInfo(const std::string &name)
  136|      0|      : SymbolName(name), IsTemporallyTracked(false), IsCrossContext(false) {}
  137|       |};
  138|       |
  139|       |// Base class for LTL formula nodes
  140|       |class LTLFormulaNode {
  141|       |public:
  142|       |  LTLNodeType Type;
  143|       |  std::string DiagnosticLabel;
  144|       |  std::vector<std::shared_ptr<LTLFormulaNode>> Children;
  145|       |  SymbolBinding Binding;    // Member that needed explicit initialization
  146|       |  std::string FunctionName; // For atomic propositions
  147|       |  std::string Value;        // For atomic propositions
  148|       |  // Stable node identity for mapping into external monitors (e.g., SPOT)
  149|       |  int NodeID;
  150|       |  // Parent pointer to support ancestor-based diagnostic selection
  151|       |  LTLFormulaNode *Parent;
  152|       |
  153|       |  LTLFormulaNode(LTLNodeType t, const std::string &label = "")
  154|     14|      : Type(t), DiagnosticLabel(label), Children(),
  155|     14|        Binding(BindingType::Variable, ""), FunctionName(), Value(),
  156|     14|        NodeID(nextNodeID()), Parent(nullptr) {}
  157|       |
  158|     14|  virtual ~LTLFormulaNode() = default;
  159|       |
  160|       |  // Convert node to string representation
  161|       |  virtual std::string toString() const = 0;
  162|       |
  163|       |  // Get structural information for automaton generation
  164|       |  virtual std::string getStructuralInfo() const = 0;
  165|       |
  166|       |  // Add diagnostic label to this node
  167|      3|  LTLFormulaNode *withDiagnostic(const std::string &label) {
  168|      3|    DiagnosticLabel = label;
  169|      3|    return this;
  170|      3|  }
  171|       |
  172|       |  // Utilities
  173|     14|  static int nextNodeID() {
  174|     14|    static int Counter = 0;
  175|     14|    return ++Counter;
  176|     14|  }
  177|       |};
  178|       |
  179|       |// Atomic proposition node (function calls, variables)
  180|       |class AtomicNode : public LTLFormulaNode {
  181|       |public:
  182|       |  AtomicNode(const std::string &funcName, const SymbolBinding &binding,
  183|       |             const std::string &value = "")
  184|      4|      : LTLFormulaNode(LTLNodeType::Atomic) {
  185|      4|    FunctionName = funcName;
  186|      4|    Binding = binding;
  187|      4|    Value = value;
  188|      4|  }
  189|       |
  190|      0|  std::string toString() const override {
  191|      0|    std::string result;
  192|      0|    if (!FunctionName.empty()) {
  193|      0|      result = FunctionName + "(" + Binding.SymbolName + ")";
  194|      0|    } else {
  195|      0|      result = Binding.SymbolName;
  196|      0|    }
  197|       |
  198|      0|    if (!DiagnosticLabel.empty()) {
  199|      0|      result += " [" + DiagnosticLabel + "]";
  200|      0|    }
  201|      0|    return result;
  202|      0|  }
  203|       |
  204|      0|  std::string getStructuralInfo() const override {
  205|      0|    return "Atomic[" + FunctionName + "(" + Binding.SymbolName + ")]";
  206|      0|  }
  207|       |};
  208|       |
  209|       |// Binary operator node (And, Or, Implies, Until, Release)
  210|       |class BinaryOpNode : public LTLFormulaNode {
  211|       |public:
  212|       |  BinaryOpNode(LTLNodeType type, std::shared_ptr<LTLFormulaNode> left,
  213|       |               std::shared_ptr<LTLFormulaNode> right)
  214|      4|      : LTLFormulaNode(type) {
  215|      4|    Children.push_back(left);
  216|      4|    Children.push_back(right);
  217|      4|    if (left)
  218|      4|      left->Parent = this;
  219|      4|    if (right)
  220|      4|      right->Parent = this;
  221|      4|  }
  222|       |
  223|      0|  std::string toString() const override {
  224|      0|    std::string op;
  225|      0|    switch (Type) {
  226|      0|    case LTLNodeType::And:
  227|      0|      op = " ∧ ";
  228|      0|      break;
  229|      0|    case LTLNodeType::Or:
  230|      0|      op = " ∨ ";
  231|      0|      break;
  232|      0|    case LTLNodeType::Implies:
  233|      0|      op = " → ";
  234|      0|      break;
  235|      0|    case LTLNodeType::Until:
  236|      0|      op = " U ";
  237|      0|      break;
  238|      0|    case LTLNodeType::Release:
  239|      0|      op = " R ";
  240|      0|      break;
  241|      0|    default:
  242|      0|      op = " ? ";
  243|      0|    }
  244|      0|    std::string result =
  245|      0|        "(" + Children[0]->toString() + op + Children[1]->toString() + ")";
  246|       |
  247|      0|    if (!DiagnosticLabel.empty()) {
  248|      0|      result += " [" + DiagnosticLabel + "]";
  249|      0|    }
  250|      0|    return result;
  251|      0|  }
  252|       |
  253|      0|  std::string getStructuralInfo() const override {
  254|      0|    std::string op;
  255|      0|    switch (Type) {
  256|      0|    case LTLNodeType::And:
  257|      0|      op = "And";
  258|      0|      break;
  259|      0|    case LTLNodeType::Or:
  260|      0|      op = "Or";
  261|      0|      break;
  262|      0|    case LTLNodeType::Implies:
  263|      0|      op = "Implies";
  264|      0|      break;
  265|      0|    case LTLNodeType::Until:
  266|      0|      op = "Until";
  267|      0|      break;
  268|      0|    case LTLNodeType::Release:
  269|      0|      op = "Release";
  270|      0|      break;
  271|      0|    default:
  272|      0|      op = "BinaryOp";
  273|      0|    }
  274|      0|    return op + "(" + Children[0]->getStructuralInfo() + ", " +
  275|      0|           Children[1]->getStructuralInfo() + ")";
  276|      0|  }
  277|       |};
  278|       |
  279|       |// Unary operator node (Not, Globally, Eventually, Next)
  280|       |class UnaryOpNode : public LTLFormulaNode {
  281|       |public:
  282|       |  UnaryOpNode(LTLNodeType type, std::shared_ptr<LTLFormulaNode> child)
  283|      6|      : LTLFormulaNode(type) {
  284|      6|    Children.push_back(child);
  285|      6|    if (child)
  286|      6|      child->Parent = this;
  287|      6|  }
  288|       |
  289|      0|  std::string toString() const override {
  290|      0|    std::string op;
  291|      0|    switch (Type) {
  292|      0|    case LTLNodeType::Not:
  293|      0|      op = "¬";
  294|      0|      break;
  295|      0|    case LTLNodeType::Globally:
  296|      0|      op = "G";
  297|      0|      break;
  298|      0|    case LTLNodeType::Eventually:
  299|      0|      op = "F";
  300|      0|      break;
  301|      0|    case LTLNodeType::Next:
  302|      0|      op = "X";
  303|      0|      break;
  304|      0|    default:
  305|      0|      op = "?";
  306|      0|    }
  307|      0|    std::string result = op + "(" + Children[0]->toString() + ")";
  308|       |
  309|      0|    if (!DiagnosticLabel.empty()) {
  310|      0|      result += " [" + DiagnosticLabel + "]";
  311|      0|    }
  312|      0|    return result;
  313|      0|  }
  314|       |
  315|      0|  std::string getStructuralInfo() const override {
  316|      0|    std::string op;
  317|      0|    switch (Type) {
  318|      0|    case LTLNodeType::Not:
  319|      0|      op = "Not";
  320|      0|      break;
  321|      0|    case LTLNodeType::Globally:
  322|      0|      op = "Globally";
  323|      0|      break;
  324|      0|    case LTLNodeType::Eventually:
  325|      0|      op = "Eventually";
  326|      0|      break;
  327|      0|    case LTLNodeType::Next:
  328|      0|      op = "Next";
  329|      0|      break;
  330|      0|    default:
  331|      0|      op = "UnaryOp";
  332|      0|    }
  333|      0|    return op + "(" + Children[0]->getStructuralInfo() + ")";
  334|      0|  }
  335|       |};
  336|       |
  337|       |// DSL builder functions for constructing LTL formulas
  338|       |namespace DSL {
  339|       |inline std::shared_ptr<LTLFormulaNode> Call(const std::string &funcName,
  340|      2|                                            const SymbolBinding &binding) {
  341|      2|  return std::make_shared<AtomicNode>(funcName, binding);
  342|      2|}
  343|       |
  344|       |inline std::shared_ptr<LTLFormulaNode>
  345|      0|ReturnVal(const std::string &symbolName) {
  346|      0|  return std::make_shared<AtomicNode>(
  347|      0|      "", SymbolBinding(BindingType::ReturnValue, symbolName));
  348|      0|}
  349|       |
  350|       |inline std::shared_ptr<LTLFormulaNode>
  351|      0|FirstParamVal(const std::string &symbolName) {
  352|      0|  return std::make_shared<AtomicNode>(
  353|      0|      "", SymbolBinding(BindingType::FirstParameter, symbolName));
  354|      0|}
  355|       |
  356|       |inline std::shared_ptr<LTLFormulaNode>
  357|      0|NthParamVal(const std::string &symbolName, int index) {
  358|      0|  return std::make_shared<AtomicNode>(
  359|      0|      "", SymbolBinding(BindingType::NthParameter, symbolName, index));
  360|      0|}
  361|       |
  362|      1|inline std::shared_ptr<LTLFormulaNode> Var(const std::string &symbolName) {
  363|      1|  return std::make_shared<AtomicNode>(
  364|      1|      "", SymbolBinding(BindingType::Variable, symbolName));
  365|      1|}
  366|       |
  367|       |inline std::shared_ptr<LTLFormulaNode>
  368|       |And(std::shared_ptr<LTLFormulaNode> left,
  369|      2|    std::shared_ptr<LTLFormulaNode> right) {
  370|      2|  return std::make_shared<BinaryOpNode>(LTLNodeType::And, left, right);
  371|      2|}
  372|       |
  373|       |inline std::shared_ptr<LTLFormulaNode>
  374|       |Or(std::shared_ptr<LTLFormulaNode> left,
  375|      0|   std::shared_ptr<LTLFormulaNode> right) {
  376|      0|  return std::make_shared<BinaryOpNode>(LTLNodeType::Or, left, right);
  377|      0|}
  378|       |
  379|       |inline std::shared_ptr<LTLFormulaNode>
  380|       |Implies(std::shared_ptr<LTLFormulaNode> left,
  381|      2|        std::shared_ptr<LTLFormulaNode> right) {
  382|      2|  return std::make_shared<BinaryOpNode>(LTLNodeType::Implies, left, right);
  383|      2|}
  384|       |
  385|       |inline std::shared_ptr<LTLFormulaNode>
  386|      3|G(std::shared_ptr<LTLFormulaNode> child) {
  387|      3|  return std::make_shared<UnaryOpNode>(LTLNodeType::Globally, child);
  388|      3|}
  389|       |
  390|       |inline std::shared_ptr<LTLFormulaNode>
  391|      1|F(std::shared_ptr<LTLFormulaNode> child) {
  392|      1|  return std::make_shared<UnaryOpNode>(LTLNodeType::Eventually, child);
  393|      1|}
  394|       |
  395|       |inline std::shared_ptr<LTLFormulaNode>
  396|      0|X(std::shared_ptr<LTLFormulaNode> child) {
  397|      0|  return std::make_shared<UnaryOpNode>(LTLNodeType::Next, child);
  398|      0|}
  399|       |
  400|       |inline std::shared_ptr<LTLFormulaNode>
  401|      2|Not(std::shared_ptr<LTLFormulaNode> child) {
  402|      2|  return std::make_shared<UnaryOpNode>(LTLNodeType::Not, child);
  403|      2|}
  404|       |
  405|       |inline std::shared_ptr<LTLFormulaNode>
  406|      0|NotNull(std::shared_ptr<LTLFormulaNode> var) {
  407|      0|  return Not(Var(var->Binding.SymbolName));
  408|      0|}
  409|       |
  410|       |// Predicate atom: symbol is provably non-null along the current path
  411|       |inline std::shared_ptr<LTLFormulaNode>
  412|      1|IsNonNull(const std::string &symbolName) {
  413|      1|  auto node = std::make_shared<AtomicNode>("__isnonnull", SymbolBinding(BindingType::Variable, symbolName));
  414|      1|  return node;
  415|      1|}
  416|       |
  417|       |inline std::shared_ptr<LTLFormulaNode>
  418|      0|IsNonNull(std::shared_ptr<LTLFormulaNode> var) {
  419|      0|  return IsNonNull(var->Binding.SymbolName);
  420|      0|}
  421|       |} // namespace DSL
  422|       |
  423|       |// General Symbolic Value Persistence System
  424|       |// This system ensures that symbolic values are consistently shared across
  425|       |// different contexts and program points, using GDM for cross-context symbol
  426|       |// storage.
  427|       |
  428|       |// Symbol usage patterns in formulas
  429|       |enum class SymbolUsagePattern {
  430|       |  SingleOccurrence,     // Symbol appears only once
  431|       |  MultipleOccurrences,  // Symbol appears multiple times in same context
  432|       |  CrossTemporalContext, // Symbol appears in different temporal contexts (G, F,
  433|       |                        // etc.)
  434|       |  CrossSubformula,  // Symbol appears in different subformulas of same context
  435|       |  CrossProgramPoint // Symbol appears at different program points (exploded
  436|       |                    // nodes)
  437|       |};
  438|       |
  439|       |// Symbolic value binding information
  440|       |struct SymbolicBindingInfo {
  441|       |  std::string SymbolName;
  442|       |  std::set<std::string>
  443|       |      TemporalContexts;              // Which temporal contexts use this symbol
  444|       |  std::set<std::string> Subformulas; // Which subformulas use this symbol
  445|       |  std::set<SourceLocation>
  446|       |      ProgramPoints;             // Program points where symbol is referenced
  447|       |  bool NeedsGDMStorage;          // Whether symbol needs GDM storage
  448|       |  SymbolRef StoredSymbolicValue; // The actual symbolic value stored in GDM
  449|       |
  450|       |  SymbolicBindingInfo()
  451|      1|      : SymbolName(""), NeedsGDMStorage(false), StoredSymbolicValue(nullptr) {}
  452|       |
  453|       |  SymbolicBindingInfo(const std::string &name)
  454|      0|      : SymbolName(name), NeedsGDMStorage(false), StoredSymbolicValue(nullptr) {
  455|      0|  }
  456|       |};
  457|       |
  458|       |// General symbolic value persistence manager
  459|       |class SymbolicValuePersistenceManager {
  460|       |private:
  461|       |  std::map<std::string, SymbolicBindingInfo> SymbolInfo;
  462|       |  std::set<std::string> SymbolsNeedingGDM;
  463|       |
  464|       |public:
  465|       |  // Analyze LTL formula for symbolic value persistence requirements
  466|       |  void
  467|      1|  analyzeFormulaForPersistence(const std::shared_ptr<LTLFormulaNode> &formula) {
  468|      1|    SymbolInfo.clear();
  469|      1|    SymbolsNeedingGDM.clear();
  470|       |
  471|       |    // Recursively analyze the formula tree
  472|      1|    analyzeNodeForPersistence(formula, "root", SourceLocation());
  473|       |
  474|       |    // Determine which symbols need GDM storage
  475|      1|    determineGDMRequirements();
  476|       |
  477|       |    // Setup cross-context symbol sharing
  478|      1|    setupCrossContextSharing();
  479|      1|  }
  480|       |
  481|       |  // Get all symbols that need GDM storage
  482|      0|  const std::set<std::string> &getSymbolsNeedingGDM() const {
  483|      0|    return SymbolsNeedingGDM;
  484|      0|  }
  485|       |
  486|       |  // Get binding info for a specific symbol
  487|       |  const SymbolicBindingInfo *
  488|      0|  getSymbolInfo(const std::string &symbolName) const {
  489|      0|    auto it = SymbolInfo.find(symbolName);
  490|      0|    return it != SymbolInfo.end() ? &it->second : nullptr;
  491|      0|  }
  492|       |
  493|       |  // Check if a symbol needs GDM storage
  494|      0|  bool needsGDMStorage(const std::string &symbolName) const {
  495|      0|    return SymbolsNeedingGDM.find(symbolName) != SymbolsNeedingGDM.end();
  496|      0|  }
  497|       |
  498|       |  // Get all temporal contexts that use a symbol
  499|       |  std::set<std::string>
  500|      0|  getTemporalContextsForSymbol(const std::string &symbolName) const {
  501|      0|    const auto *info = getSymbolInfo(symbolName);
  502|      0|    return info ? info->TemporalContexts : std::set<std::string>();
  503|      0|  }
  504|       |
  505|       |  // Get all subformulas that use a symbol
  506|       |  std::set<std::string>
  507|      0|  getSubformulasForSymbol(const std::string &symbolName) const {
  508|      0|    const auto *info = getSymbolInfo(symbolName);
  509|      0|    return info ? info->Subformulas : std::set<std::string>();
  510|      0|  }
  511|       |
  512|       |  // Generate persistence analysis report
  513|      0|  std::string generatePersistenceReport() const {
  514|      0|    std::string report = "Symbolic Value Persistence Analysis:\n";
  515|      0|    report += "Symbols requiring GDM storage: " +
  516|      0|              std::to_string(SymbolsNeedingGDM.size()) + "\n\n";
  517|      0|
  518|      0|    for (const auto &symbol : SymbolsNeedingGDM) {
  519|      0|      const auto *info = getSymbolInfo(symbol);
  520|      0|      if (info) {
  521|      0|        report += "Symbol: " + symbol + "\n";
  522|      0|        report += "  Temporal Contexts: " +
  523|      0|                  std::to_string(info->TemporalContexts.size()) + "\n";
  524|      0|        report +=
  525|      0|            "  Subformulas: " + std::to_string(info->Subformulas.size()) + "\n";
  526|      0|        report +=
  527|      0|            "  Program Points: " + std::to_string(info->ProgramPoints.size()) +
  528|      0|            "\n";
  529|      0|        report +=
  530|      0|            "  GDM Storage: " +
  531|      0|            std::string(info->NeedsGDMStorage ? "Required" : "Not Required") +
  532|      0|            "\n\n";
  533|      0|      }
  534|      0|    }
  535|      0|
  536|      0|    return report;
  537|      0|  }
  538|       |
  539|       |private:
  540|       |  // Recursively analyze LTL formula nodes for persistence requirements
  541|       |  void analyzeNodeForPersistence(const std::shared_ptr<LTLFormulaNode> &node,
  542|       |                                 const std::string &context,
  543|     14|                                 SourceLocation location) {
  544|     14|    if (!node)
  545|      0|      return;
  546|       |
  547|       |    // Analyze based on node type
  548|     14|    switch (node->Type) {
  549|      5|    case LTLNodeType::Atomic:
  550|      5|      analyzeAtomicNodeForPersistence(node, context, location);
  551|      5|      break;
  552|      2|    case LTLNodeType::And:
  553|      2|    case LTLNodeType::Or:
  554|      4|    case LTLNodeType::Implies:
  555|      4|      analyzeBinaryOpNodeForPersistence(node, context, location);
  556|      4|      break;
  557|      1|    case LTLNodeType::Not:
  558|      4|    case LTLNodeType::Globally:
  559|      5|    case LTLNodeType::Eventually:
  560|      5|    case LTLNodeType::Next:
  561|      5|      analyzeUnaryOpNodeForPersistence(node, context, location);
  562|      5|      break;
  563|      0|    case LTLNodeType::Until:
  564|      0|    case LTLNodeType::Release:
  565|      0|      analyzeBinaryOpNodeForPersistence(node, context, location);
  566|      0|      break;
  567|     14|    }
  568|     14|  }
  569|       |
  570|       |  // Analyze atomic propositions for persistence requirements
  571|       |  void
  572|       |  analyzeAtomicNodeForPersistence(const std::shared_ptr<LTLFormulaNode> &node,
  573|       |                                  const std::string &context,
  574|      5|                                  SourceLocation location) {
  575|      5|    if (node->Binding.SymbolName.empty()) {
  576|      0|      return; // No symbol binding
  577|      0|    }
  578|       |
  579|      5|    std::string symbolName = node->Binding.SymbolName;
  580|       |
  581|       |    // Get or create symbol info
  582|      5|    auto &info = SymbolInfo[symbolName];
  583|      5|    info.SymbolName = symbolName;
  584|       |
  585|       |    // Record temporal context
  586|      5|    info.TemporalContexts.insert(context);
  587|       |
  588|       |    // Record subformula (using function name as subformula identifier)
  589|      5|    if (!node->FunctionName.empty()) {
  590|      5|      info.Subformulas.insert(node->FunctionName);
  591|      5|    }
  592|       |
  593|       |    // Record program point (if available)
  594|      5|    if (location.isValid()) {
  595|      0|      info.ProgramPoints.insert(location);
  596|      0|    }
  597|      5|  }
  598|       |
  599|       |  // Analyze binary operators for persistence requirements
  600|       |  void
  601|       |  analyzeBinaryOpNodeForPersistence(const std::shared_ptr<LTLFormulaNode> &node,
  602|       |                                    const std::string &context,
  603|      4|                                    SourceLocation location) {
  604|      8|    for (const auto &child : node->Children) {
  605|      8|      analyzeNodeForPersistence(child, context, location);
  606|      8|    }
  607|      4|  }
  608|       |
  609|       |  // Analyze unary operators for persistence requirements
  610|       |  void
  611|       |  analyzeUnaryOpNodeForPersistence(const std::shared_ptr<LTLFormulaNode> &node,
  612|       |                                   const std::string &context,
  613|      5|                                   SourceLocation location) {
  614|       |    // Create new temporal context for temporal operators
  615|      5|    std::string newContext = context;
  616|      5|    switch (node->Type) {
  617|      3|    case LTLNodeType::Globally:
  618|      3|      newContext += ".G";
  619|      3|      break;
  620|      1|    case LTLNodeType::Eventually:
  621|      1|      newContext += ".F";
  622|      1|      break;
  623|      0|    case LTLNodeType::Next:
  624|      0|      newContext += ".X";
  625|      0|      break;
  626|      1|    default:
  627|      1|      break;
  628|      5|    }
  629|       |
  630|       |    // Analyze children in the new context
  631|      5|    for (const auto &child : node->Children) {
  632|      5|      analyzeNodeForPersistence(child, newContext, location);
  633|      5|    }
  634|      5|  }
  635|       |
  636|       |  // Determine which symbols need GDM storage based on usage patterns
  637|      1|  void determineGDMRequirements() {
  638|      1|    for (auto &pair : SymbolInfo) {
  639|      1|      auto &info = pair.second;
  640|       |
  641|       |      // Check usage patterns to determine if GDM storage is needed
  642|      1|      bool needsGDM = false;
  643|       |
  644|       |      // Pattern 1: Multiple temporal contexts
  645|      1|      if (info.TemporalContexts.size() > 1) {
  646|      1|        needsGDM = true;
  647|      1|      }
  648|       |
  649|       |      // Pattern 2: Multiple subformulas (even in same context)
  650|      1|      if (info.Subformulas.size() > 1) {
  651|      1|        needsGDM = true;
  652|      1|      }
  653|       |
  654|       |      // Pattern 3: Multiple program points
  655|      1|      if (info.ProgramPoints.size() > 1) {
  656|      0|        needsGDM = true;
  657|      0|      }
  658|       |
  659|       |      // Pattern 4: Multiple occurrences in general
  660|      1|      if (info.TemporalContexts.size() + info.Subformulas.size() > 2) {
  661|      1|        needsGDM = true;
  662|      1|      }
  663|       |
  664|      1|      info.NeedsGDMStorage = needsGDM;
  665|      1|      if (needsGDM) {
  666|      1|        SymbolsNeedingGDM.insert(info.SymbolName);
  667|      1|      }
  668|      1|    }
  669|      1|  }
  670|       |
  671|       |  // Setup cross-context symbol sharing mechanisms
  672|      1|  void setupCrossContextSharing() {
  673|       |    // This will be called by the framework to set up the cross-context sharing
  674|       |    // The actual sharing logic is implemented in the event handlers
  675|      1|  }
  676|       |};
  677|       |
  678|       |// LTL State for Büchi automaton
  679|       |class LTLState {
  680|       |public:
  681|       |  std::string StateID;
  682|       |  std::set<std::string> AtomicPropositions;
  683|       |  std::vector<std::string> PendingFormulas;
  684|       |  bool IsAccepting;
  685|       |  std::string DiagnosticLabel;
  686|       |
  687|       |  LTLState(const std::string &id, bool accepting = false)
  688|      0|      : StateID(id), IsAccepting(accepting) {}
  689|       |
  690|      0|  void addAtomicProposition(const std::string &prop) {
  691|      0|    AtomicPropositions.insert(prop);
  692|      0|  }
  693|       |
  694|      0|  void addPendingFormula(const std::string &formula) {
  695|      0|    PendingFormulas.push_back(formula);
  696|      0|  }
  697|       |};
  698|       |
  699|       |// Büchi automaton for LTL monitoring
  700|       |class LTLAutomaton {
  701|       |private:
  702|       |  std::vector<std::shared_ptr<LTLState>> States;
  703|       |  std::map<std::pair<std::string, std::set<std::string>>,
  704|       |           std::shared_ptr<LTLState>>
  705|       |      Transitions;
  706|       |  std::map<std::string, std::string> DiagnosticLabels;
  707|       |  std::shared_ptr<LTLState> InitialState;
  708|       |
  709|       |public:
  710|       |  LTLAutomaton() = default;
  711|       |
  712|      0|  void addState(std::shared_ptr<LTLState> state) {
  713|      0|    States.push_back(state);
  714|      0|    if (!InitialState) {
  715|      0|      InitialState = state;
  716|      0|    }
  717|      0|  }
  718|       |
  719|       |  void addTransition(std::shared_ptr<LTLState> from,
  720|       |                     const std::set<std::string> &props,
  721|      0|                     std::shared_ptr<LTLState> to) {
  722|      0|    Transitions[{from->StateID, props}] = to;
  723|      0|  }
  724|       |
  725|       |  void setDiagnosticLabel(const std::string &stateID,
  726|      0|                          const std::string &label) {
  727|      0|    DiagnosticLabels[stateID] = label;
  728|      0|  }
  729|       |
  730|       |  std::shared_ptr<LTLState>
  731|       |  processEvent(std::shared_ptr<LTLState> currentState,
  732|      0|               const std::set<std::string> &propositions) {
  733|      0|    auto key = std::make_pair(currentState->StateID, propositions);
  734|      0|    auto it = Transitions.find(key);
  735|      0|    return it != Transitions.end() ? it->second : currentState;
  736|      0|  }
  737|       |
  738|      0|  bool isAccepting(std::shared_ptr<LTLState> state) const {
  739|      0|    return state && state->IsAccepting;
  740|      0|  }
  741|       |
  742|      0|  std::string getDiagnosticLabel(std::shared_ptr<LTLState> state) const {
  743|      0|    if (!state)
  744|      0|      return "";
  745|      0|    auto it = DiagnosticLabels.find(state->StateID);
  746|      0|    return it != DiagnosticLabels.end() ? it->second : "";
  747|      0|  }
  748|       |
  749|      0|  std::shared_ptr<LTLState> getInitialState() const { return InitialState; }
  750|       |
  751|      0|  const std::vector<std::shared_ptr<LTLState>> &getStates() const {
  752|      0|    return States;
  753|      0|  }
  754|       |};
  755|       |
  756|       |// LTL Parser for converting formula structure to Büchi automaton
  757|       |class LTLParser {
  758|       |private:
  759|       |  std::shared_ptr<LTLFormulaNode> RootFormula;
  760|       |  std::map<std::string, std::shared_ptr<LTLState>> StateMap;
  761|       |  int StateCounter;
  762|       |
  763|       |public:
  764|       |  LTLParser(std::shared_ptr<LTLFormulaNode> formula)
  765|      0|      : RootFormula(formula), StateCounter(0) {}
  766|       |
  767|       |  // Generate Büchi automaton from LTL formula
  768|      0|  std::unique_ptr<LTLAutomaton> generateAutomaton() {
  769|      0|    auto automaton = std::make_unique<LTLAutomaton>();
  770|      0|
  771|      0|    if (!RootFormula) {
  772|      0|      return automaton;
  773|      0|    }
  774|      0|
  775|      0|    // Create initial state with the root formula
  776|      0|    auto initialState = createState("q0", false);
  777|      0|    initialState->addPendingFormula(RootFormula->getStructuralInfo());
  778|      0|
  779|      0|    automaton->addState(initialState);
  780|      0|
  781|      0|    // Recursively build the automaton
  782|      0|    buildAutomatonStates(RootFormula, initialState, automaton.get());
  783|      0|
  784|      0|    return automaton;
  785|      0|  }
  786|       |
  787|       |private:
  788|       |  // Create a new state
  789|       |  std::shared_ptr<LTLState> createState(const std::string &prefix,
  790|      0|                                        bool accepting) {
  791|      0|    std::string stateID = prefix + "_" + std::to_string(StateCounter++);
  792|      0|    return std::make_shared<LTLState>(stateID, accepting);
  793|      0|  }
  794|       |
  795|       |  // Recursively build automaton states from formula
  796|       |  void buildAutomatonStates(std::shared_ptr<LTLFormulaNode> formula,
  797|       |                            std::shared_ptr<LTLState> currentState,
  798|      0|                            LTLAutomaton *automaton) {
  799|      0|    if (!formula || !currentState || !automaton)
  800|      0|      return;
  801|      0|
  802|      0|    switch (formula->Type) {
  803|      0|    case LTLNodeType::Atomic:
  804|      0|      buildAtomicState(formula, currentState, automaton);
  805|      0|      break;
  806|      0|    case LTLNodeType::And:
  807|      0|      buildAndState(formula, currentState, automaton);
  808|      0|      break;
  809|      0|    case LTLNodeType::Or:
  810|      0|      buildOrState(formula, currentState, automaton);
  811|      0|      break;
  812|      0|    case LTLNodeType::Implies:
  813|      0|      buildImpliesState(formula, currentState, automaton);
  814|      0|      break;
  815|      0|    case LTLNodeType::Not:
  816|      0|      buildNotState(formula, currentState, automaton);
  817|      0|      break;
  818|      0|    case LTLNodeType::Globally:
  819|      0|      buildGloballyState(formula, currentState, automaton);
  820|      0|      break;
  821|      0|    case LTLNodeType::Eventually:
  822|      0|      buildEventuallyState(formula, currentState, automaton);
  823|      0|      break;
  824|      0|    case LTLNodeType::Next:
  825|      0|      buildNextState(formula, currentState, automaton);
  826|      0|      break;
  827|      0|    default:
  828|      0|      break;
  829|      0|    }
  830|      0|  }
  831|       |
  832|       |  // Build state for atomic proposition
  833|       |  void buildAtomicState(std::shared_ptr<LTLFormulaNode> formula,
  834|       |                        std::shared_ptr<LTLState> currentState,
  835|      0|                        LTLAutomaton *automaton) {
  836|      0|    if (!formula || !currentState || !automaton)
  837|      0|      return;
  838|      0|
  839|      0|    // Add atomic proposition to current state
  840|      0|    std::string prop = formula->toString();
  841|      0|    currentState->AtomicPropositions.insert(prop);
  842|      0|
  843|      0|    // Add diagnostic label if present
  844|      0|    if (!formula->DiagnosticLabel.empty()) {
  845|      0|      currentState->DiagnosticLabel = formula->DiagnosticLabel;
  846|      0|    }
  847|      0|
  848|      0|    // Add state to automaton
  849|      0|    automaton->addState(currentState);
  850|      0|  }
  851|       |
  852|       |  // Build state for binary operators
  853|       |  void buildAndState(std::shared_ptr<LTLFormulaNode> formula,
  854|       |                     std::shared_ptr<LTLState> currentState,
  855|      0|                     LTLAutomaton *automaton) {
  856|      0|    if (!formula || !currentState || !automaton || formula->Children.size() < 2)
  857|      0|      return;
  858|      0|
  859|      0|    // Process both children
  860|      0|    buildAutomatonStates(formula->Children[0], currentState, automaton);
  861|      0|    buildAutomatonStates(formula->Children[1], currentState, automaton);
  862|      0|  }
  863|       |
  864|       |  void buildOrState(std::shared_ptr<LTLFormulaNode> formula,
  865|       |                    std::shared_ptr<LTLState> currentState,
  866|      0|                    LTLAutomaton *automaton) {
  867|      0|    if (!formula || !currentState || !automaton || formula->Children.size() < 2)
  868|      0|      return;
  869|      0|
  870|      0|    // Create separate states for each child
  871|      0|    auto leftState = createState("or_left", false);
  872|      0|    auto rightState = createState("or_right", false);
  873|      0|
  874|      0|    buildAutomatonStates(formula->Children[0], leftState, automaton);
  875|      0|    buildAutomatonStates(formula->Children[1], rightState, automaton);
  876|      0|
  877|      0|    // Add transitions from current state to both children
  878|      0|    automaton->addTransition(currentState, std::set<std::string>(), leftState);
  879|      0|    automaton->addTransition(currentState, std::set<std::string>(), rightState);
  880|      0|  }
  881|       |
  882|       |  void buildImpliesState(std::shared_ptr<LTLFormulaNode> formula,
  883|       |                         std::shared_ptr<LTLState> currentState,
  884|      0|                         LTLAutomaton *automaton) {
  885|      0|    if (!formula || !currentState || !automaton || formula->Children.size() < 2)
  886|      0|      return;
  887|      0|
  888|      0|    // A → B is equivalent to ¬A ∨ B
  889|      0|    auto notA =
  890|      0|        std::make_shared<UnaryOpNode>(LTLNodeType::Not, formula->Children[0]);
  891|      0|    auto orNode = std::make_shared<BinaryOpNode>(LTLNodeType::Or, notA,
  892|      0|                                                 formula->Children[1]);
  893|      0|
  894|      0|    buildOrState(orNode, currentState, automaton);
  895|      0|  }
  896|       |
  897|       |  // Build state for unary operators
  898|       |  void buildNotState(std::shared_ptr<LTLFormulaNode> formula,
  899|       |                     std::shared_ptr<LTLState> currentState,
  900|      0|                     LTLAutomaton *automaton) {
  901|      0|    if (!formula || !currentState || !automaton || formula->Children.empty())
  902|      0|      return;
  903|      0|
  904|      0|    // For now, just process the child
  905|      0|    buildAutomatonStates(formula->Children[0], currentState, automaton);
  906|      0|  }
  907|       |
  908|       |  void buildGloballyState(std::shared_ptr<LTLFormulaNode> formula,
  909|       |                          std::shared_ptr<LTLState> currentState,
  910|      0|                          LTLAutomaton *automaton) {
  911|      0|    if (!formula || !currentState || !automaton || formula->Children.empty())
  912|      0|      return;
  913|      0|
  914|      0|    // G φ means φ must be true in all future states
  915|      0|    // Create a loop state that always requires φ
  916|      0|    auto loopState = createState("globally", true);
  917|      0|    buildAutomatonStates(formula->Children[0], loopState, automaton);
  918|      0|
  919|      0|    // Add transition from current state to loop state
  920|      0|    automaton->addTransition(currentState, std::set<std::string>(), loopState);
  921|      0|    // Add self-loop to maintain the globally property
  922|      0|    automaton->addTransition(loopState, std::set<std::string>(), loopState);
  923|      0|  }
  924|       |
  925|       |  void buildEventuallyState(std::shared_ptr<LTLFormulaNode> formula,
  926|       |                            std::shared_ptr<LTLState> currentState,
  927|      0|                            LTLAutomaton *automaton) {
  928|      0|    if (!formula || !currentState || !automaton || formula->Children.empty())
  929|      0|      return;
  930|      0|
  931|      0|    // F φ means φ must eventually be true
  932|      0|    // Create a state that can accept φ at any time
  933|      0|    auto eventuallyState = createState("eventually", false);
  934|      0|    buildAutomatonStates(formula->Children[0], eventuallyState, automaton);
  935|      0|
  936|      0|    // Add transition from current state to eventually state
  937|      0|    automaton->addTransition(currentState, std::set<std::string>(),
  938|      0|                             eventuallyState);
  939|      0|    // Add self-loop to allow waiting for φ
  940|      0|    automaton->addTransition(currentState, std::set<std::string>(),
  941|      0|                             currentState);
  942|      0|  }
  943|       |
  944|       |  void buildNextState(std::shared_ptr<LTLFormulaNode> formula,
  945|       |                      std::shared_ptr<LTLState> currentState,
  946|      0|                      LTLAutomaton *automaton) {
  947|      0|    if (!formula || !currentState || !automaton || formula->Children.empty())
  948|      0|      return;
  949|      0|
  950|      0|    // X φ means φ must be true in the next state
  951|      0|    auto nextState = createState("next", false);
  952|      0|    buildAutomatonStates(formula->Children[0], nextState, automaton);
  953|      0|
  954|      0|    // Add transition from current state to next state
  955|      0|    automaton->addTransition(currentState, std::set<std::string>(), nextState);
  956|      0|  }
  957|       |};
  958|       |
  959|       |// Forward declaration
  960|       |class LTLFormulaBuilder;
  961|       |
  962|       |// Binding-driven event creation system
  963|       |class BindingDrivenEventCreator {
  964|       |private:
  965|       |  std::map<std::string, std::map<std::string, BindingType>> FunctionBindings;
  966|       |
  967|       |public:
  968|       |  // Register function binding information from DSL formula
  969|       |  void registerFunctionBinding(const std::string &functionName,
  970|       |                               const std::string &symbolName,
  971|      5|                               BindingType bindingType) {
  972|      5|    FunctionBindings[functionName][symbolName] = bindingType;
  973|      5|  }
  974|       |
  975|       |  // Get binding type for a function and symbol
  976|       |  BindingType getBindingType(const std::string &functionName,
  977|     19|                             const std::string &symbolName) const {
  978|     19|    auto funcIt = FunctionBindings.find(functionName);
  979|     19|    if (funcIt != FunctionBindings.end()) {
  980|     19|      auto symbolIt = funcIt->second.find(symbolName);
  981|     19|      if (symbolIt != funcIt->second.end()) {
  982|     19|        return symbolIt->second;
  983|     19|      }
  984|     19|    }
  985|      0|    return BindingType::Variable; // Default fallback
  986|     19|  }
  987|       |
  988|       |  // Extract symbol from call event based on binding type
  989|       |  SymbolRef extractSymbolFromCall(const CallEvent &Call,
  990|       |                                  const std::string &functionName,
  991|      8|                                  const std::string &symbolName) const {
  992|      8|    BindingType bindingType = getBindingType(functionName, symbolName);
  993|       |
  994|      8|    switch (bindingType) {
  995|      6|    case BindingType::ReturnValue:
  996|      6|      return Call.getReturnValue().getAsSymbol();
  997|       |
  998|      2|    case BindingType::FirstParameter:
  999|      2|      return Call.getNumArgs() > 0 ? Call.getArgSVal(0).getAsSymbol() : nullptr;
                                                                                      ^0
 1000|       |
 1001|      0|    case BindingType::NthParameter:
 1002|       |      // For now, assume first parameter - could be enhanced to track parameter
 1003|       |      // index
 1004|      0|      return Call.getNumArgs() > 0 ? Call.getArgSVal(0).getAsSymbol() : nullptr;
 1005|       |
 1006|      0|    case BindingType::Variable:
 1007|      0|    default:
 1008|      0|      return nullptr;
 1009|      8|    }
 1010|      8|  }
 1011|       |
 1012|       |  // Check if we have binding information for a function
 1013|      4|  bool hasBindingInfo(const std::string &functionName) const {
 1014|      4|    return FunctionBindings.find(functionName) != FunctionBindings.end();
 1015|      4|  }
 1016|       |};
 1017|       |
 1018|       |// Enhanced LTL Formula Builder with general symbolic value persistence
 1019|       |class LTLFormulaBuilder {
 1020|       |private:
 1021|       |  std::shared_ptr<LTLFormulaNode> RootFormula;
 1022|       |  SymbolicValuePersistenceManager PersistenceManager;
 1023|       |  std::vector<std::string> DiagnosticLabels;
 1024|       |  std::vector<SymbolBinding> SymbolBindings;
 1025|       |  std::set<std::string> FunctionNames;
 1026|       |  // Map node IDs to nodes for external mappings (e.g., SPOT APs)
 1027|       |  std::map<int, LTLFormulaNode *> IdToNode;
 1028|       |
 1029|       |public:
 1030|      1|  LTLFormulaBuilder() = default;
 1031|       |
 1032|      1|  void setFormula(std::shared_ptr<LTLFormulaNode> formula) {
 1033|      1|    RootFormula = formula;
 1034|       |
 1035|       |    // Analyze formula for symbolic value persistence requirements
 1036|      1|    PersistenceManager.analyzeFormulaForPersistence(formula);
 1037|       |
 1038|       |    // Extract diagnostic labels
 1039|      1|    extractDiagnosticLabels(formula);
 1040|       |
 1041|       |    // Extract symbol bindings
 1042|      1|    extractSymbolBindings(formula);
 1043|       |
 1044|       |    // Extract function names
 1045|      1|    extractFunctionNames(formula);
 1046|       |
 1047|       |    // Index nodes by NodeID and set parent pointers recursively (safety)
 1048|      1|    indexNodes(formula.get());
 1049|      1|  }
 1050|       |
 1051|      0|  std::string getFormulaString() const {
 1052|      0|    return RootFormula ? RootFormula->toString() : "";
 1053|      0|  }
 1054|       |
 1055|      0|  std::string getStructuralInfo() const {
 1056|      0|    if (!RootFormula)
 1057|      0|      return "";
 1058|      0|
 1059|      0|    std::string info = "Formula Structure:\n";
 1060|      0|    info += "  Root: " + RootFormula->getStructuralInfo() + "\n";
 1061|      0|    info += "  Symbols requiring GDM: " +
 1062|      0|            std::to_string(PersistenceManager.getSymbolsNeedingGDM().size()) +
 1063|      0|            "\n";
 1064|      0|
 1065|      0|    for (const auto &symbol : PersistenceManager.getSymbolsNeedingGDM()) {
 1066|      0|      const auto *info_ptr = PersistenceManager.getSymbolInfo(symbol);
 1067|      0|      if (info_ptr) {
 1068|      0|        info += "    - " + symbol + " (";
 1069|      0|        info +=
 1070|      0|            "contexts: " + std::to_string(info_ptr->TemporalContexts.size()) +
 1071|      0|            ", ";
 1072|      0|        info += "subformulas: " + std::to_string(info_ptr->Subformulas.size()) +
 1073|      0|                ", ";
 1074|      0|        info +=
 1075|      0|            "program points: " + std::to_string(info_ptr->ProgramPoints.size());
 1076|      0|        info += ")\n";
 1077|      0|      }
 1078|      0|    }
 1079|      0|
 1080|      0|    return info;
 1081|      0|  }
 1082|       |
 1083|      0|  std::vector<std::string> getDiagnosticLabels() const {
 1084|      0|    return DiagnosticLabels;
 1085|      0|  }
 1086|       |
 1087|      4|  std::vector<SymbolBinding> getSymbolBindings() const {
 1088|      4|    return SymbolBindings;
 1089|      4|  }
 1090|       |
 1091|      1|  std::set<std::string> getFunctionNames() const { return FunctionNames; }
 1092|       |
 1093|       |  // New methods for general symbolic value persistence
 1094|      0|  const SymbolicValuePersistenceManager &getPersistenceManager() const {
 1095|      0|    return PersistenceManager;
 1096|      0|  }
 1097|       |
 1098|      0|  std::set<std::string> getSymbolsNeedingGDM() const {
 1099|      0|    return PersistenceManager.getSymbolsNeedingGDM();
 1100|      0|  }
 1101|       |
 1102|      0|  bool needsGDMStorage(const std::string &symbolName) const {
 1103|      0|    return PersistenceManager.needsGDMStorage(symbolName);
 1104|      0|  }
 1105|       |
 1106|      0|  std::string getPersistenceReport() const {
 1107|      0|    return PersistenceManager.generatePersistenceReport();
 1108|      0|  }
 1109|       |
 1110|       |  // Expose the root for external traversals (e.g., SPOT conversion)
 1111|      1|  const LTLFormulaNode *getRootNode() const { return RootFormula.get(); }
 1112|       |
 1113|       |  // Lookup node by ID
 1114|     24|  LTLFormulaNode *getNodeByID(int id) const {
 1115|     24|    auto it = IdToNode.find(id);
 1116|     24|    return it == IdToNode.end() ? nullptr : it->second;
                                                ^6        ^18
 1117|     24|  }
 1118|       |
 1119|       |  // Find nearest ancestor (including self) carrying a diagnostic label
 1120|      0|  const LTLFormulaNode *findNearestDiagnosticAncestor(const LTLFormulaNode *node) const {
 1121|      0|    const LTLFormulaNode *cur = node;
 1122|      0|    while (cur) {
 1123|      0|      if (!cur->DiagnosticLabel.empty())
 1124|      0|        return cur;
 1125|      0|      cur = cur->Parent;
 1126|      0|    }
 1127|      0|    return nullptr;
 1128|      0|  }
 1129|       |
 1130|      0|  std::unique_ptr<LTLAutomaton> generateAutomaton() const {
 1131|      0|    if (!RootFormula) {
 1132|      0|      return nullptr;
 1133|      0|    }
 1134|      0|
 1135|      0|    LTLParser parser(RootFormula);
 1136|      0|    return parser.generateAutomaton();
 1137|      0|  }
 1138|       |
 1139|       |  // Extract binding information for event creation
 1140|       |  void
 1141|      1|  populateBindingDrivenEventCreator(BindingDrivenEventCreator &creator) const {
 1142|      1|    if (!RootFormula) {
 1143|      0|      return;
 1144|      0|    }
 1145|       |
 1146|      1|    extractFunctionBindings(RootFormula, creator);
 1147|      1|  }
 1148|       |
 1149|       |private:
 1150|     14|  void extractDiagnosticLabels(const std::shared_ptr<LTLFormulaNode> &node) {
 1151|     14|    if (!node)
 1152|      0|      return;
 1153|       |
 1154|     14|    if (!node->DiagnosticLabel.empty()) {
 1155|      3|      DiagnosticLabels.push_back(node->DiagnosticLabel);
 1156|      3|    }
 1157|       |
 1158|     14|    for (const auto &child : node->Children) {
 1159|     13|      extractDiagnosticLabels(child);
 1160|     13|    }
 1161|     14|  }
 1162|       |
 1163|     14|  void extractSymbolBindings(const std::shared_ptr<LTLFormulaNode> &node) {
 1164|     14|    if (!node)
 1165|      0|      return;
 1166|       |
 1167|     14|    if (!node->Binding.SymbolName.empty()) {
 1168|      5|      SymbolBindings.push_back(node->Binding);
 1169|      5|    }
 1170|       |
 1171|     14|    for (const auto &child : node->Children) {
 1172|     13|      extractSymbolBindings(child);
 1173|     13|    }
 1174|     14|  }
 1175|       |
 1176|     14|  void extractFunctionNames(const std::shared_ptr<LTLFormulaNode> &node) {
 1177|     14|    if (!node)
 1178|      0|      return;
 1179|       |
 1180|     14|    if (!node->FunctionName.empty()) {
 1181|      5|      FunctionNames.insert(node->FunctionName);
 1182|      5|    }
 1183|       |
 1184|     14|    for (const auto &child : node->Children) {
 1185|     13|      extractFunctionNames(child);
 1186|     13|    }
 1187|     14|  }
 1188|       |
 1189|       |  void extractFunctionBindings(const std::shared_ptr<LTLFormulaNode> &node,
 1190|     14|                               BindingDrivenEventCreator &creator) const {
 1191|     14|    if (!node)
 1192|      0|      return;
 1193|       |
 1194|       |    // If this is an atomic node with a function name and binding, register it
 1195|     14|    if (!node->FunctionName.empty() && !node->Binding.SymbolName.empty()) {
                                                     ^5
 1196|      5|      creator.registerFunctionBinding(
 1197|      5|          node->FunctionName, node->Binding.SymbolName, node->Binding.Type);
 1198|      5|    }
 1199|       |
 1200|       |    // Recursively process children
 1201|     14|    for (const auto &child : node->Children) {
 1202|     13|      extractFunctionBindings(child, creator);
 1203|     13|    }
 1204|     14|  }
 1205|       |
 1206|     14|  void indexNodes(LTLFormulaNode *node) {
 1207|     14|    if (!node)
 1208|      0|      return;
 1209|     14|    IdToNode[node->NodeID] = node;
 1210|     14|    for (const auto &child : node->Children) {
 1211|     13|      if (child && child->Parent == nullptr)
 1212|      0|        child->Parent = node;
 1213|     13|      indexNodes(child.get());
 1214|     13|    }
 1215|     14|  }
 1216|       |};
 1217|       |
 1218|       |// Generic event types for the framework
 1219|       |enum class EventType {
 1220|       |  PostCall,   // Function call completed
 1221|       |  PreCall,    // Function call about to start
 1222|       |  DeadSymbols, // Symbols are no longer reachable
 1223|       |  EndFunction, // Function is ending; finalize obligations for this frame
 1224|       |  PointerEscape // Symbol escapes current function/frame ownership
 1225|       |};
 1226|       |
 1227|       |// Generic event structure
 1228|       |struct GenericEvent {
 1229|       |  EventType Type;
 1230|       |  std::string FunctionName;
 1231|       |  std::string SymbolName;
 1232|       |  SymbolRef Symbol;
 1233|       |  SourceLocation Location;
 1234|       |
 1235|       |  GenericEvent(EventType t, const std::string &func, const std::string &sym,
 1236|       |               SymbolRef s, SourceLocation loc)
 1237|      9|      : Type(t), FunctionName(func), SymbolName(sym), Symbol(s), Location(loc) {
 1238|      9|  }
 1239|       |};
 1240|       |
 1241|       |// Generic event handler interface
 1242|       |class EventHandler {
 1243|       |public:
 1244|      0|  virtual ~EventHandler() = default;
 1245|       |  virtual void handleEvent(const GenericEvent &event, CheckerContext &C) = 0;
 1246|       |  virtual std::string getDescription() const = 0;
 1247|       |};
 1248|       |
 1249|       |// Property definition interface
 1250|       |class PropertyDefinition {
 1251|       |public:
 1252|      1|  virtual ~PropertyDefinition() = default;
 1253|       |  virtual std::unique_ptr<EventHandler>
 1254|       |  createEventHandler(const CheckerBase *Checker) = 0;
 1255|       |  virtual std::string getTemporalLogicFormula() const = 0;
 1256|       |  virtual std::string getPropertyName() const = 0;
 1257|       |  virtual LTLFormulaBuilder getFormulaBuilder() const = 0;
 1258|       |};
 1259|       |
 1260|       |// Monitor automaton that handles generic events
 1261|       |class MonitorAutomaton {
 1262|       |  std::string PropertyName;
 1263|       |  LTLFormulaBuilder FormulaBuilder;
 1264|       |  const CheckerBase *Checker;
 1265|       |  BindingDrivenEventCreator EventCreator;
 1266|       |  // SPOT-backed monitor is owned in the checker TU to avoid header cycles
 1267|       |
 1268|       |public:
 1269|       |  MonitorAutomaton(std::unique_ptr<PropertyDefinition> prop,
 1270|       |                   const CheckerBase *C)
 1271|      1|      : PropertyName(prop->getPropertyName()),
 1272|      1|        FormulaBuilder(prop->getFormulaBuilder()), Checker(C) {
 1273|       |    // Populate binding-driven event creator with formula information
 1274|      1|    FormulaBuilder.populateBindingDrivenEventCreator(EventCreator);
 1275|       |    // Temporal monitoring is handled by the SPOT-based monitor in the checker TU.
 1276|      1|  }
 1277|       |
 1278|      6|  void handleEvent(const GenericEvent &event, CheckerContext &C) {
 1279|      6|    if (edslDebugEnabled()) {
 1280|      6|      llvm::errs() << "[EDSL] handleEvent: type=";
 1281|      6|      switch (event.Type) {
 1282|      2|      case EventType::PostCall: llvm::errs() << "PostCall"; break;
 1283|      2|      case EventType::PreCall: llvm::errs() << "PreCall"; break;
 1284|      0|      case EventType::DeadSymbols: llvm::errs() << "DeadSymbols"; break;
 1285|      2|      case EventType::EndFunction: llvm::errs() << "EndFunction"; break;
 1286|      0|      case EventType::PointerEscape: llvm::errs() << "PointerEscape"; break;
 1287|      6|      }
 1288|      6|      llvm::errs() << ", fn=" << event.FunctionName
 1289|      6|                   << ", sym=" << event.SymbolName << "\n";
 1290|      6|    }
 1291|       |    // Generic, checker-agnostic lifecycle modeling driven by bindings.
 1292|       |    // This block purposefully contains no malloc/free specific strings.
 1293|      6|    ProgramStateRef State = C.getState();
 1294|       |
 1295|      6|    switch (event.Type) {
 1296|      2|    case EventType::PostCall: {
 1297|      2|      if (event.Symbol && !event.FunctionName.empty() && !event.SymbolName.empty()) {
 1298|       |        // Treat a PostCall bound to a ReturnValue as a creation event
 1299|      2|        BindingType BT = EventCreator.getBindingType(event.FunctionName, event.SymbolName);
 1300|      2|        if (BT == BindingType::ReturnValue) {
 1301|      1|            if (edslDebugEnabled()) {
 1302|      1|              llvm::errs() << "[EDSL] create: " << event.FunctionName << "(" << event.SymbolName << ") -> Potential\n";
 1303|      1|            }
 1304|       |            // Mark as Potential; will promote to Active on first non-null proof.
 1305|      1|            State = State->set<::SymbolStates>(event.Symbol, ::SymbolState::Uninitialized);
 1306|       |            // Region association is recorded via checkBind; nothing to do here
 1307|       |            // Track potential for end-of-function leak consideration
 1308|      1|            State = State->add<::FunctionEndLeakSet>(event.Symbol);
 1309|       |            // Add a binding note similar to checker format for traceability
 1310|      1|            std::string internal = "sym_" + std::to_string(event.Symbol->getSymbolID());
 1311|      1|            std::string var = event.SymbolName.empty() ? std::string("x") : event.SymbolName;
                                                                       ^0
 1312|      1|            std::string note = std::string("symbol \"") + var + "\" is bound here (internal symbol: " + internal + ")";
 1313|      1|            const NoteTag *NT = C.getNoteTag([note]() { return note; });
 1314|      1|            C.addTransition(State, NT);
 1315|      1|        }
 1316|      2|      }
 1317|      2|      break;
 1318|      0|    }
 1319|      2|    case EventType::PreCall: {
 1320|      2|      if (event.Symbol && !event.FunctionName.empty() && !event.SymbolName.empty()) {
                                        ^1                             ^1
 1321|       |        // Treat a PreCall bound to a parameter as a destruction event
 1322|      1|        BindingType BT = EventCreator.getBindingType(event.FunctionName, event.SymbolName);
 1323|      1|        if (BT == BindingType::FirstParameter || BT == BindingType::NthParameter) {
                                                               ^0
 1324|      1|          const ::SymbolState *CurPtr = State->get<::SymbolStates>(event.Symbol);
 1325|      1|          ::SymbolState Cur = CurPtr ? *CurPtr : ::SymbolState::Uninitialized;
                                                               ^0
 1326|       |          // Promote to Active only from Potential (Uninitialized) if not provably null
 1327|      1|          ProgramStateRef __S = C.getState();
 1328|      1|          ConditionTruthVal __IsNull = C.getConstraintManager().isNull(__S, event.Symbol);
 1329|      1|          if (Cur == ::SymbolState::Uninitialized && !__IsNull.isConstrainedTrue()) {
 1330|      1|            State = State->set<::SymbolStates>(event.Symbol, ::SymbolState::Active);
 1331|      1|            State = State->add<::PendingLeakSet>(event.Symbol);
 1332|      1|            State = State->remove<::FunctionEndLeakSet>(event.Symbol);
 1333|      1|          }
 1334|      1|          const ::SymbolState *CurPtr2 = State->get<::SymbolStates>(event.Symbol);
 1335|      1|          ::SymbolState Cur2 = CurPtr2 ? *CurPtr2 : ::SymbolState::Uninitialized;
                                                                  ^0
 1336|      1|          if (Cur2 == ::SymbolState::Active) {
 1337|      1|            if (edslDebugEnabled()) {
 1338|      1|              llvm::errs() << "[EDSL] destroy: " << event.FunctionName << "(" << event.SymbolName << ") -> Inactive\n";
 1339|      1|            }
 1340|      1|            State = State->set<::SymbolStates>(event.Symbol, ::SymbolState::Inactive);
 1341|      1|            State = State->remove<::GenericSymbolMap>(event.Symbol);
 1342|      1|            State = State->remove<::PendingLeakSet>(event.Symbol);
 1343|      1|            State = State->remove<::FunctionEndLeakSet>(event.Symbol);
 1344|      1|            C.addTransition(State);
 1345|      1|          } else if (Cur2 == ::SymbolState::Inactive) {
                               ^0  ^0
 1346|      0|            if (edslDebugEnabled()) {
 1347|      0|              llvm::errs() << "[EDSL] double-destroy detected for sym " << event.SymbolName << "\n";
 1348|      0|            }
 1349|       |            // Double destruction: emit violation
 1350|      0|            ExplodedNode *ErrorNode = C.generateErrorNode(C.getState());
 1351|      0|            if (ErrorNode) {
 1352|      0|              static const BugType BT{Checker, "temporal_violation", "EmbeddedDSLMonitor"};
 1353|      0|              std::string msg = "resource destroyed twice (violates exactly-once)";
 1354|      0|              std::string internal = "sym_" + std::to_string(event.Symbol->getSymbolID());
 1355|      0|              msg += " (internal symbol: " + internal + ")";
 1356|      0|              auto R = std::make_unique<PathSensitiveBugReport>(BT, msg, ErrorNode);
 1357|      0|              R->markInteresting(event.Symbol);
 1358|      0|              C.emitReport(std::move(R));
 1359|      0|            }
 1360|      0|          }
 1361|      1|        }
 1362|      1|      }
 1363|      2|      break;
 1364|      0|    }
 1365|      0|    case EventType::DeadSymbols: {
 1366|       |      // Intentionally no-op here; leaks reported at EndFunction for better location
 1367|      0|      break;
 1368|      0|    }
 1369|      0|    case EventType::PointerEscape: {
 1370|      0|      if (event.Symbol) {
 1371|       |        // Transfer ownership out of this frame: do not report leak here
 1372|      0|        if (edslDebugEnabled()) {
 1373|      0|          llvm::errs() << "[EDSL] escape: dropping PendingLeak obligation for "
 1374|      0|                       << event.SymbolName << "\n";
 1375|      0|        }
 1376|      0|        State = State->remove<::PendingLeakSet>(event.Symbol);
 1377|      0|        C.addTransition(State);
 1378|      0|      }
 1379|      0|      break;
 1380|      0|    }
 1381|      2|    case EventType::EndFunction: {
 1382|       |      // Emit leaks for any symbols still pending at function end.
 1383|      2|      if (edslDebugEnabled()) {
 1384|      2|        unsigned pendingCount = 0;
 1385|      2|        for (auto _ : State->get<::PendingLeakSet>()) (void)_, ++pendingCount;
                                                                    ^0
 1386|      2|        llvm::errs() << "[EDSL] end-function: pending=" << pendingCount << "\n";
 1387|      2|      }
 1388|       |      // Report leaks for symbols promoted to Active but not destroyed
 1389|      2|      for (auto Sym : State->get<::PendingLeakSet>()) {
 1390|       |        // If the symbol is provably null on this path, drop obligation silently.
 1391|       |        // Strengthen nullness by checking the associated region if available.
 1392|      0|        ConditionTruthVal __IsNull = C.getConstraintManager().isNull(State, Sym);
 1393|      0|        if (!__IsNull.isConstrainedTrue()) {
 1394|      0|          if (const MemRegion *const *MRP = State->get<::SymbolToRegionMap>(Sym)) {
 1395|      0|            const MemRegion *MR = *MRP;
 1396|      0|            SVal RV = State->getSVal(MR);
 1397|      0|            if (SymbolRef RSym = RV.getAsSymbol()) {
 1398|      0|              __IsNull = C.getConstraintManager().isNull(State, RSym);
 1399|      0|            } else if (RV.isZeroConstant()) {
 1400|      0|              __IsNull = ConditionTruthVal(true);
 1401|      0|            }
 1402|      0|          }
 1403|      0|        }
 1404|      0|        if (edslDebugEnabled()) {
 1405|      0|          const ::SymbolState *CurPtr = State->get<::SymbolStates>(Sym);
 1406|      0|          ::SymbolState Cur = CurPtr ? *CurPtr : ::SymbolState::Uninitialized;
 1407|      0|          llvm::errs() << "[EDSL] end-function pending: sym=" << Sym->getSymbolID()
 1408|      0|                       << " state=" << (int)Cur
 1409|      0|                       << " isNull=" << (__IsNull.isConstrainedTrue() ? "T" : (__IsNull.isConstrainedFalse() ? "F" : "U"))
 1410|      0|                       << "\n";
 1411|      0|        }
 1412|      0|        if (__IsNull.isConstrainedTrue()) {
 1413|      0|          State = State->remove<::GenericSymbolMap>(Sym);
 1414|      0|          State = State->remove<::SymbolStates>(Sym);
 1415|      0|          State = State->remove<::PendingLeakSet>(Sym);
 1416|      0|          continue;
 1417|      0|        }
 1418|       |        // Ensure we have a fresh node to attach diagnostics
 1419|      0|        C.addTransition(State);
 1420|      0|        ExplodedNode *ErrorNode = C.generateErrorNode(State);
 1421|      0|        if (ErrorNode) {
 1422|      0|          static const BugType BT{Checker, "temporal_violation", "EmbeddedDSLMonitor"};
 1423|      0|          std::string msg = "resource not destroyed (violates exactly-once)";
 1424|      0|          std::string internal = "sym_" + std::to_string(Sym->getSymbolID());
 1425|      0|          msg += " (internal symbol: " + internal + ")";
 1426|      0|          auto R = std::make_unique<PathSensitiveBugReport>(BT, msg, ErrorNode);
 1427|      0|          R->markInteresting(Sym);
 1428|       |          // Hint for path location: end-of-function
 1429|      0|          const NoteTag *EndTag = C.getNoteTag([]() { return std::string("function ends here"); });
 1430|      0|          C.addTransition(C.getState(), EndTag);
 1431|      0|          C.emitReport(std::move(R));
 1432|      0|        }
 1433|      0|        State = State->remove<::GenericSymbolMap>(Sym);
 1434|      0|        State = State->remove<::SymbolStates>(Sym);
 1435|      0|        State = State->remove<::PendingLeakSet>(Sym);
 1436|      0|      }
 1437|       |      // Consider potentials: if provably non-null at end, report once; drop if provably null
 1438|      2|      for (auto Sym : State->get<::FunctionEndLeakSet>()) {
 1439|      1|        ConditionTruthVal __IsNull = C.getConstraintManager().isNull(State, Sym);
 1440|      1|        if (!__IsNull.isConstrainedTrue()) {
 1441|      1|          if (const MemRegion *const *MRP = State->get<::SymbolToRegionMap>(Sym)) {
 1442|      0|            const MemRegion *MR = *MRP;
 1443|      0|            SVal RV = State->getSVal(MR);
 1444|      0|            if (SymbolRef RSym = RV.getAsSymbol()) {
 1445|      0|              __IsNull = C.getConstraintManager().isNull(State, RSym);
 1446|      0|            } else if (RV.isZeroConstant()) {
 1447|      0|              __IsNull = ConditionTruthVal(true);
 1448|      0|            }
 1449|      0|          }
 1450|      1|        }
 1451|      1|        if (edslDebugEnabled()) {
 1452|      1|          const ::SymbolState *CurPtr = State->get<::SymbolStates>(Sym);
 1453|      1|          ::SymbolState Cur = CurPtr ? *CurPtr : ::SymbolState::Uninitialized;
                                                               ^0
 1454|      1|          llvm::errs() << "[EDSL] end-function potential: sym=" << Sym->getSymbolID()
 1455|      1|                       << " state=" << (int)Cur
 1456|      1|                       << " isNull=" << (__IsNull.isConstrainedTrue() ? "T" : (__IsNull.isConstrainedFalse() ? "F" : "U"))
                                                                                      ^0                                     ^0
 1457|      1|                       << "\n";
 1458|      1|        }
 1459|       |        // Report if not provably null at function end (unknown or non-null)
 1460|      1|        if (!__IsNull.isConstrainedTrue()) {
 1461|       |          // Ensure we have a fresh node to attach diagnostics
 1462|      1|          C.addTransition(State);
 1463|      1|          ExplodedNode *ErrorNode = C.generateErrorNode(State);
 1464|      1|          if (ErrorNode) {
 1465|      1|            static const BugType BT{Checker, "temporal_violation", "EmbeddedDSLMonitor"};
 1466|      1|            std::string msg = "resource not destroyed (violates exactly-once)";
 1467|      1|            std::string internal = "sym_" + std::to_string(Sym->getSymbolID());
 1468|      1|            msg += " (internal symbol: " + internal + ")";
 1469|      1|            auto R = std::make_unique<PathSensitiveBugReport>(BT, msg, ErrorNode);
 1470|      1|            R->markInteresting(Sym);
 1471|      1|            const NoteTag *EndTag = C.getNoteTag([]() { return std::string("function ends here"); });
                                                                    ^0
 1472|      1|            C.addTransition(C.getState(), EndTag);
 1473|      1|            C.emitReport(std::move(R));
 1474|      1|          }
 1475|      1|        }
 1476|      1|        State = State->remove<::GenericSymbolMap>(Sym);
 1477|      1|        State = State->remove<::SymbolStates>(Sym);
 1478|      1|        State = State->remove<::FunctionEndLeakSet>(Sym);
 1479|      1|      }
 1480|      2|      C.addTransition(State);
 1481|      2|      break;
 1482|      0|    }
 1483|      6|    }
 1484|      6|  }
 1485|       |
 1486|      0|  std::string getPropertyName() const { return PropertyName; }
 1487|     27|  LTLFormulaBuilder getFormulaBuilder() const { return FormulaBuilder; }
 1488|       |
 1489|       |  // Extract atomic propositions from an event
 1490|      0|  std::set<std::string> extractPropositions(const GenericEvent &event, CheckerContext &C) const {
 1491|      0|    std::set<std::string> propositions;
 1492|      0|    ProgramStateRef State = C.getState();
 1493|      0|
 1494|      0|    // Add function call proposition
 1495|      0|    if (!event.FunctionName.empty()) {
 1496|      0|      propositions.insert(event.FunctionName + "(" + event.SymbolName + ")");
 1497|      0|    }
 1498|      0|
 1499|      0|    // Add symbol proposition if available
 1500|      0|    if (!event.SymbolName.empty() && event.SymbolName != "unknown") {
 1501|      0|      propositions.insert(event.SymbolName);
 1502|      0|    }
 1503|      0|
 1504|      0|    return propositions;
 1505|      0|  }
 1506|       |
 1507|       |  // Create event using binding-driven approach
 1508|       |  dsl::GenericEvent createBindingDrivenEvent(const CallEvent &Call,
 1509|       |                                             EventType eventType,
 1510|      4|                                             CheckerContext &C) const {
 1511|      4|    std::string funcName = Call.getCalleeIdentifier()
 1512|      4|                               ? Call.getCalleeIdentifier()->getName().str()
 1513|      4|                               : "unknown";
                                               ^0
 1514|       |
 1515|       |    // If we have binding information for this function, use it
 1516|      4|    if (EventCreator.hasBindingInfo(funcName)) {
 1517|       |      // For now, we'll use the first symbol we find for this function
 1518|       |      // In a more sophisticated implementation, we could match symbols more
 1519|       |      // precisely
 1520|      4|      SymbolRef Sym = nullptr;
 1521|      4|      std::string symbolName = "unknown";
 1522|       |
 1523|       |      // Try to find a symbol using the binding information
 1524|       |      // This is a simplified approach - in practice, we'd need more
 1525|       |      // sophisticated matching
 1526|      8|      for (const auto &binding : FormulaBuilder.getSymbolBindings()) {
 1527|      8|        if (EventCreator.getBindingType(funcName, binding.SymbolName) !=
 1528|      8|            BindingType::Variable) {
 1529|      8|          Sym = EventCreator.extractSymbolFromCall(Call, funcName,
 1530|      8|                                                   binding.SymbolName);
 1531|      8|          if (Sym) {
 1532|      3|            symbolName = binding.SymbolName;
 1533|      3|            break;
 1534|      3|          }
 1535|      8|        }
 1536|      8|      }
 1537|       |
 1538|       |      // If binding-based extraction failed, fall back to default extraction
 1539|      4|      if (!Sym) {
 1540|      1|      if (eventType == EventType::PostCall) {
 1541|      0|        Sym = Call.getReturnValue().getAsSymbol();
 1542|      0|        symbolName = Sym ? "sym_" + std::to_string(Sym->getSymbolID()) : "unknown";
 1543|      1|      } else {
 1544|       |        // Prefer the underlying stored symbol of the region argument, if any
 1545|      1|        Sym = nullptr;
 1546|      1|        if (Call.getNumArgs() > 0) {
 1547|      1|          SVal Arg = Call.getArgSVal(0);
 1548|      1|          if (const MemRegion *MR = Arg.getAsRegion()) {
 1549|      0|            SVal Stored = C.getState()->getSVal(MR);
 1550|      0|            if (SymbolRef StoredSym = Stored.getAsSymbol()) {
 1551|      0|              Sym = StoredSym;
 1552|      0|            }
 1553|      0|          }
 1554|      1|          if (!Sym)
 1555|      1|            Sym = Arg.getAsSymbol();
 1556|      1|        }
 1557|      1|        symbolName = Sym ? "sym_" + std::to_string(Sym->getSymbolID()) : "unknown";
                                         ^0
 1558|      1|      }
 1559|      1|      }
 1560|       |
 1561|      4|      return dsl::GenericEvent(eventType, funcName, symbolName, Sym,
 1562|      4|                               Call.getSourceRange().getBegin());
 1563|      4|    } else {
 1564|       |      // Fallback to traditional approach
 1565|      0|      SymbolRef Sym = nullptr;
 1566|      0|      std::string symbolName = "unknown";
 1567|       |
 1568|      0|      if (eventType == EventType::PostCall) {
 1569|      0|        Sym = Call.getReturnValue().getAsSymbol();
 1570|      0|        symbolName =
 1571|      0|            Sym ? "sym_" + std::to_string(Sym->getSymbolID()) : "unknown";
 1572|      0|      } else {
 1573|      0|        Sym = Call.getNumArgs() > 0 ? Call.getArgSVal(0).getAsSymbol() : nullptr;
 1574|      0|        symbolName =
 1575|      0|            Sym ? "sym_" + std::to_string(Sym->getSymbolID()) : "unknown";
 1576|      0|      }
 1577|       |
 1578|      0|      return dsl::GenericEvent(eventType, funcName, symbolName, Sym,
 1579|      0|                               Call.getSourceRange().getBegin());
 1580|      0|    }
 1581|      4|  }
 1582|       |
 1583|       |private:
 1584|       |  // (Legacy propositional extraction removed; SPOT handles temporal logic.)
 1585|       |
 1586|       |  // Emit diagnostic for automaton-based violations
 1587|       |  void emitDiagnostic(const std::string &diagnostic, const GenericEvent &event,
 1588|      0|                      CheckerContext &C) {
 1589|      0|    if (!event.Symbol) {
 1590|      0|      return;
 1591|      0|    }
 1592|      0|
 1593|      0|    // Generate error node
 1594|      0|    ExplodedNode *ErrorNode = C.generateErrorNode(C.getState());
 1595|      0|    if (!ErrorNode) {
 1596|      0|      return;
 1597|      0|    }
 1598|      0|
 1599|      0|    // Create generic bug type for any temporal property violation
 1600|      0|    static const BugType GenericBT{Checker, "temporal_violation",
 1601|      0|                                   "EmbeddedDSLMonitor"};
 1602|      0|    const BugType *BT = &GenericBT;
 1603|      0|
 1604|      0|    // Enhance diagnostic message with internal symbol name for correlation
 1605|      0|    std::string enhancedDiagnostic = diagnostic;
 1606|      0|    
 1607|      0|    // Add internal symbol name for correlation with notes
 1608|      0|    if (event.Symbol) {
 1609|      0|      std::string internalSymbolName = "sym_" + std::to_string(event.Symbol->getSymbolID());
 1610|      0|      enhancedDiagnostic += " (internal symbol: " + internalSymbolName + ")";
 1611|      0|    }
 1612|      0|
 1613|      0|    auto R =
 1614|      0|        std::make_unique<PathSensitiveBugReport>(*BT, enhancedDiagnostic, ErrorNode);
 1615|      0|    R->markInteresting(event.Symbol);
 1616|      0|    C.emitReport(std::move(R));
 1617|      0|  }
 1618|       |
 1619|       |  // Add a note about symbol binding
 1620|      0|  void addSymbolBindingNote(const GenericEvent &event, CheckerContext &C) {
 1621|      0|    if (!event.Symbol || !event.Location.isValid()) {
 1622|      0|      return;
 1623|      0|    }
 1624|      0|
 1625|      0|    // Determine the formula variable name
 1626|      0|    std::string formulaVar = "x"; // Default formula variable name
 1627|      0|    
 1628|      0|    // Try to find the actual formula variable name from the binding
 1629|      0|    for (const auto &binding : FormulaBuilder.getSymbolBindings()) {
 1630|      0|      if (binding.SymbolName == event.SymbolName) {
 1631|      0|        formulaVar = binding.SymbolName;
 1632|      0|        break;
 1633|      0|      }
 1634|      0|    }
 1635|      0|
 1636|      0|    // Create the note message
 1637|      0|    std::string internalSymbolName = "sym_" + std::to_string(event.Symbol->getSymbolID());
 1638|      0|    std::string noteMessage = "symbol \"" + formulaVar + "\" is bound here (internal symbol: " + 
 1639|      0|                             internalSymbolName + ")";
 1640|      0|
 1641|      0|    // Create a note using getNoteTag
 1642|      0|    const NoteTag *noteTag = C.getNoteTag([noteMessage]() { return noteMessage; });
 1643|      0|    C.addTransition(C.getState(), noteTag);
 1644|      0|  }
 1645|       |};
 1646|       |
 1647|       |// Generic ASTMatchers wrapper
 1648|       |class PatternMatcher {
 1649|       |public:
 1650|      0|  static bool isNotNull(SymbolRef Sym, CheckerContext &C) {
 1651|      0|    ProgramStateRef State = C.getState();
 1652|      0|    ConditionTruthVal IsNull = C.getConstraintManager().isNull(State, Sym);
 1653|      0|    return !IsNull.isConstrainedTrue();
 1654|      0|  }
 1655|       |};
 1656|       |
 1657|       |// Generic symbol tracking via symbol-based GDM
 1658|       |class SymbolTracker {
 1659|       |public:
 1660|       |  static void trackSymbol(ProgramStateRef State, SymbolRef sym,
 1661|      0|                          const std::string &value, CheckerContext &C) {
 1662|      0|    C.addTransition(State->set<::GenericSymbolMap>(sym, value));
 1663|      0|  }
 1664|       |
 1665|      0|  static std::string getSymbolValue(ProgramStateRef State, SymbolRef sym) {
 1666|      0|    if (const std::string *value = State->get<::GenericSymbolMap>(sym)) {
 1667|      0|      return *value;
 1668|      0|    }
 1669|      0|    return "";
 1670|      0|  }
 1671|       |
 1672|       |  static void removeSymbol(ProgramStateRef State, SymbolRef sym,
 1673|      0|                           CheckerContext &C) {
 1674|      0|    C.addTransition(State->remove<::GenericSymbolMap>(sym));
 1675|      0|  }
 1676|       |
 1677|      0|  static bool hasSymbol(ProgramStateRef State, SymbolRef sym) {
 1678|      0|    return State->get<::GenericSymbolMap>(sym) != nullptr;
 1679|      0|  }
 1680|       |};
 1681|       |
 1682|       |// Generic Event Handler for any temporal property
 1683|       |class GenericEventHandler : public EventHandler {
 1684|       |private:
 1685|       |  const CheckerBase *Checker;
 1686|       |
 1687|       |public:
 1688|      0|  GenericEventHandler(const CheckerBase *C) : Checker(C) {}
 1689|       |
 1690|      0|  std::string getDescription() const override {
 1691|      0|    return "Generic temporal property monitor";
 1692|      0|  }
 1693|       |
 1694|      0|  void handleEvent(const GenericEvent &event, CheckerContext &C) override {
 1695|       |    // Generic event handling - all logic is now in the automaton
 1696|       |    // This handler can be extended for custom event processing if needed
 1697|      0|    (void)event;
 1698|      0|    (void)C;
 1699|      0|  }
 1700|       |};
 1701|       |
 1702|       |// Generic Property Implementation
 1703|       |class GenericProperty : public PropertyDefinition {
 1704|       |private:
 1705|       |  LTLFormulaBuilder FormulaBuilder;
 1706|       |  std::string PropertyName;
 1707|       |  std::string FormulaString;
 1708|       |
 1709|       |public:
 1710|       |  GenericProperty(const std::string &name, const std::string &formulaStr,
 1711|       |                  std::shared_ptr<LTLFormulaNode> formula)
 1712|      1|      : PropertyName(name), FormulaString(formulaStr) {
 1713|      1|    FormulaBuilder.setFormula(formula);
 1714|      1|  }
 1715|       |
 1716|      0|  std::string getTemporalLogicFormula() const override { return FormulaString; }
 1717|       |
 1718|      1|  std::string getPropertyName() const override { return PropertyName; }
 1719|       |
 1720|      1|  LTLFormulaBuilder getFormulaBuilder() const override {
 1721|      1|    return FormulaBuilder;
 1722|      1|  }
 1723|       |
 1724|       |  std::unique_ptr<EventHandler>
 1725|      0|  createEventHandler(const CheckerBase *Checker) override {
 1726|      0|    return std::make_unique<GenericEventHandler>(Checker);
 1727|      0|  }
 1728|       |};
 1729|       |
 1730|       |// Example: Mutex Lock/Unlock Property
 1731|       |// This demonstrates how the framework can be used for other temporal properties
 1732|       |class MutexLockUnlockProperty : public PropertyDefinition {
 1733|       |private:
 1734|       |  LTLFormulaBuilder FormulaBuilder;
 1735|       |
 1736|       |public:
 1737|      0|  MutexLockUnlockProperty() {
 1738|      0|    // Build the LTL formula: G( lock(x) → F unlock(x) ∧ G( unlock(x) → G
 1739|      0|    // ¬lock(x) ) ) "Globally, if a lock is acquired, it must eventually be
 1740|      0|    // released, and once released, it cannot be acquired again until it is
 1741|      0|    // released"
 1742|      0|
 1743|      0|    auto lockCall =
 1744|      0|        DSL::Call("lock", SymbolBinding(BindingType::FirstParameter, "x"));
 1745|      0|    auto unlockCall =
 1746|      0|        DSL::Call("unlock", SymbolBinding(BindingType::FirstParameter, "x"));
 1747|      0|
 1748|      0|    auto eventuallyUnlock = DSL::F(unlockCall);
 1749|      0|    eventuallyUnlock->withDiagnostic("Lock leak: acquired lock not released");
 1750|      0|
 1751|      0|    auto unlockImpliesNoMoreLock =
 1752|      0|        DSL::Implies(unlockCall, DSL::G(DSL::Not(lockCall)));
 1753|      0|    unlockImpliesNoMoreLock->withDiagnostic(
 1754|      0|        "Double lock: lock acquired multiple times");
 1755|      0|
 1756|      0|    auto globallyNoMoreLock = DSL::G(unlockImpliesNoMoreLock);
 1757|      0|
 1758|      0|    auto eventuallyUnlockAndNoMoreLock =
 1759|      0|        DSL::And(eventuallyUnlock, globallyNoMoreLock);
 1760|      0|
 1761|      0|    auto implication = DSL::Implies(lockCall, eventuallyUnlockAndNoMoreLock);
 1762|      0|
 1763|      0|    auto globallyImplication = DSL::G(implication);
 1764|      0|    globallyImplication->withDiagnostic("Mutex lock/unlock property violation");
 1765|      0|
 1766|      0|    FormulaBuilder.setFormula(globallyImplication);
 1767|      0|  }
 1768|       |
 1769|      0|  std::string getTemporalLogicFormula() const override {
 1770|      0|    return "G( lock(x) → F unlock(x) ∧ G( unlock(x) → G ¬lock(x) ) )";
 1771|      0|  }
 1772|       |
 1773|      0|  std::string getPropertyName() const override {
 1774|      0|    return "mutex_lock_unlock_exactly_once";
 1775|      0|  }
 1776|       |
 1777|      0|  LTLFormulaBuilder getFormulaBuilder() const override {
 1778|      0|    return FormulaBuilder;
 1779|      0|  }
 1780|       |
 1781|       |  std::unique_ptr<EventHandler>
 1782|      0|  createEventHandler(const CheckerBase *Checker) override {
 1783|      0|    return std::make_unique<GenericEventHandler>(Checker);
 1784|      0|  }
 1785|       |};
 1786|       |
 1787|       |} // namespace dsl
 1788|       |} // namespace ento
 1789|       |} // namespace clang
 1790|       |
 1791|       |#endif // LLVM_CLANG_STATICANALYZER_CHECKERS_EMBEDDEDDSLFRAMEWORK_H

/Users/efulop/llvm-project/clang/lib/StaticAnalyzer/Checkers/EmbeddedDSLSpot.cpp:
    1|       |#include "EmbeddedDSLSpot.h"
    2|       |
    3|       |// Minimal SPOT includes; concrete usage will be filled incrementally
    4|       |#include <spot/tl/parse.hh>
    5|       |#include <spot/tl/print.hh>
    6|       |#include <spot/twaalgos/translate.hh>
    7|       |#include <spot/twa/twagraph.hh>
    8|       |#include <spot/twa/bdddict.hh>
    9|       |#include <spot/twa/bddprint.hh>
   10|       |#include <spot/tl/formula.hh>
   11|       |
   12|       |using namespace clang;
   13|       |using namespace ento;
   14|       |using namespace dsl;
   15|       |// removed SpotMonitor in favor of unified DSLMonitor
   16|       |
   17|       |
   18|       |namespace {
   19|       |// Tiny boolean evaluator for formulas produced from BDDs using only !, &, |, (),
   20|       |// and atomic proposition names like "ap_1".
   21|       |struct BoolParser {
   22|       |  const std::string &S;
   23|       |  size_t I = 0;
   24|       |  const std::set<std::string> &TrueAPs;
   25|       |  BoolParser(const std::string &s, const std::set<std::string> &aps)
   26|      0|      : S(s), TrueAPs(aps) {}
   27|       |
   28|      0|  void skipWS() {
   29|      0|    while (I < S.size() && isspace(static_cast<unsigned char>(S[I]))) ++I;
   30|      0|  }
   31|       |
   32|      0|  bool parseExpr() {
   33|      0|    bool v = parseTerm();
   34|      0|    skipWS();
   35|      0|    while (I < S.size()) {
   36|      0|      if (S[I] == '|') {
   37|      0|        ++I;
   38|      0|        bool rhs = parseTerm();
   39|      0|        v = v || rhs;
   40|      0|        skipWS();
   41|      0|      } else {
   42|      0|        break;
   43|      0|      }
   44|      0|    }
   45|      0|    return v;
   46|      0|  }
   47|       |
   48|      0|  bool parseTerm() {
   49|      0|    bool v = parseFactor();
   50|      0|    skipWS();
   51|      0|    while (I < S.size()) {
   52|      0|      if (S[I] == '&') {
   53|      0|        ++I;
   54|      0|        bool rhs = parseFactor();
   55|      0|        v = v && rhs;
   56|      0|        skipWS();
   57|      0|      } else {
   58|      0|        break;
   59|      0|      }
   60|      0|    }
   61|      0|    return v;
   62|      0|  }
   63|       |
   64|      0|  bool parseFactor() {
   65|      0|    skipWS();
   66|      0|    if (I >= S.size()) return false;
   67|      0|    if (S[I] == '!') {
   68|      0|      ++I;
   69|      0|      return !parseFactor();
   70|      0|    }
   71|      0|    if (S[I] == '(') {
   72|      0|      ++I;
   73|      0|      bool v = parseExpr();
   74|      0|      skipWS();
   75|      0|      if (I < S.size() && S[I] == ')') ++I;
   76|      0|      return v;
   77|      0|    }
   78|      0|    // Parse identifier or constants 1/0
   79|      0|    if (S[I] == '1') { ++I; return true; }
   80|      0|    if (S[I] == '0') { ++I; return false; }
   81|      0|    size_t start = I;
   82|      0|    while (I < S.size() && (isalnum(static_cast<unsigned char>(S[I])) || S[I] == '_' || S[I] == '.')) ++I;
   83|      0|    std::string tok = S.substr(start, I - start);
   84|      0|    if (tok.empty()) return false;
   85|      0|    return TrueAPs.count(tok) != 0;
   86|      0|  }
   87|       |};
   88|       |
   89|       |
   90|      5|static std::string makeAPName(int nodeId) { return "ap_" + std::to_string(nodeId); }
   91|       |
   92|       |// Recursively build a SPOT-compatible infix PSL string from our DSL AST,
   93|       |// while registering atomic propositions and their evaluators into the registry.
   94|       |static std::string buildSpotFormulaString(const LTLFormulaNode *node,
   95|     14|                                          APRegistry &reg) {
   96|     14|  if (!node)
   97|      0|    return "1"; // true
   98|       |
   99|     14|  switch (node->Type) {
  100|      5|  case LTLNodeType::Atomic: {
  101|      5|    const int id = node->NodeID;
  102|      5|    const std::string ap = makeAPName(id);
  103|       |    // Capture values needed for evaluation
  104|      5|    const std::string fn = node->FunctionName;
  105|      5|    const std::string sym = node->Binding.SymbolName;
  106|      5|    const BindingType bt = node->Binding.Type;
  107|       |
  108|     18|    APEvaluator eval = [fn, sym, bt](const GenericEvent &E, CheckerContext &C) -> bool {
  109|       |      // Predicate: __isnonnull(x)
  110|     18|      if (fn == "__isnonnull") {
  111|      6|        if (E.Symbol && E.SymbolName == sym) {
                                      ^3
  112|      3|          ProgramStateRef S = C.getState();
  113|      3|          ConditionTruthVal IsNull = C.getConstraintManager().isNull(S, E.Symbol);
  114|       |          // Strict: true only when provably non-null on this path
  115|      3|          return IsNull.isConstrainedFalse();
  116|      3|        }
  117|      3|        return false;
  118|      6|      }
  119|       |      // Variable-only AP: true if the current event references the same symbol
  120|     12|      if (fn.empty()) {
  121|      0|        return (!sym.empty() && E.SymbolName == sym);
  122|      0|      }
  123|       |      // Function AP: true if this event is for that function on the bound symbol
  124|     12|      if (E.FunctionName != fn)
  125|      8|        return false;
  126|      4|      if (sym.empty())
  127|      0|        return true;
  128|      4|      return E.SymbolName == sym;
  129|      4|    };
  130|      5|    reg.registerAP(id, ap, std::move(eval));
  131|      5|    return ap;
  132|      0|  }
  133|      2|  case LTLNodeType::And:
  134|      2|    return std::string("(") + buildSpotFormulaString(node->Children[0].get(), reg) +
  135|      2|           " & " + buildSpotFormulaString(node->Children[1].get(), reg) + ")";
  136|      0|  case LTLNodeType::Or:
  137|      0|    return std::string("(") + buildSpotFormulaString(node->Children[0].get(), reg) +
  138|      0|           " | " + buildSpotFormulaString(node->Children[1].get(), reg) + ")";
  139|      2|  case LTLNodeType::Implies:
  140|      2|    return std::string("(") + buildSpotFormulaString(node->Children[0].get(), reg) +
  141|      2|           " -> " + buildSpotFormulaString(node->Children[1].get(), reg) + ")";
  142|      1|  case LTLNodeType::Not:
  143|      1|    return std::string("!(") + buildSpotFormulaString(node->Children[0].get(), reg) + ")";
  144|      3|  case LTLNodeType::Globally:
  145|      3|    return std::string("G(") + buildSpotFormulaString(node->Children[0].get(), reg) + ")";
  146|      1|  case LTLNodeType::Eventually:
  147|      1|    return std::string("F(") + buildSpotFormulaString(node->Children[0].get(), reg) + ")";
  148|      0|  case LTLNodeType::Next:
  149|      0|    return std::string("X(") + buildSpotFormulaString(node->Children[0].get(), reg) + ")";
  150|      0|  case LTLNodeType::Until:
  151|      0|    return std::string("(") + buildSpotFormulaString(node->Children[0].get(), reg) +
  152|      0|           " U " + buildSpotFormulaString(node->Children[1].get(), reg) + ")";
  153|      0|  case LTLNodeType::Release:
  154|      0|    return std::string("(") + buildSpotFormulaString(node->Children[0].get(), reg) +
  155|      0|           " R " + buildSpotFormulaString(node->Children[1].get(), reg) + ")";
  156|     14|  }
  157|      0|  return "1";
  158|     14|}
  159|       |
  160|       |}
  161|       |
  162|      1|SpotBuildResult dsl::buildSpotMonitorFromDSL(const LTLFormulaBuilder &Builder) {
  163|      1|  SpotBuildResult R;
  164|       |
  165|       |  // Translate DSL → infix PSL and register AP evaluators.
  166|      1|  const LTLFormulaNode *root = Builder.getRootNode();
  167|      1|  std::string infix = buildSpotFormulaString(root, R.Registry);
  168|      1|  if (infix.empty()) infix = "G 1";
                                   ^0
  169|       |
  170|       |  // Internally append an End AP evaluator so the monitor can observe function-end.
  171|       |  // The End AP is true only on EndFunction events. It is not referenced by the DSL formula yet.
  172|      1|  {
  173|      1|    const std::string apEnd = "ap_END";
  174|      6|    APEvaluator endEval = [](const GenericEvent &E, CheckerContext &C) -> bool {
  175|      6|      (void)C;
  176|      6|      return E.Type == EventType::EndFunction;
  177|      6|    };
  178|       |    // Use nodeId -1 for synthetic AP; it won't map to any DSL node.
  179|      1|    R.Registry.registerAP(-1, apEnd, std::move(endEval));
  180|      1|  }
  181|       |
  182|      1|  spot::parsed_formula pf = spot::parse_infix_psl(infix);
  183|      1|  if (pf.format_errors(std::cerr)) {
  184|      0|    return R;
  185|      0|  }
  186|      1|  spot::translator trans;
  187|      1|  trans.set_type(spot::postprocessor::Monitor);
  188|      1|  trans.set_pref(spot::postprocessor::Deterministic);
  189|      1|  R.Monitor = trans.run(pf.f);
  190|      1|  return R;
  191|      1|}
  192|       |
  193|       |std::unique_ptr<DSLMonitor> DSLMonitor::create(
  194|      1|    std::unique_ptr<PropertyDefinition> Property, const CheckerBase *O) {
  195|      1|  auto Runtime = std::make_unique<dsl::MonitorAutomaton>(std::move(Property), O);
  196|      1|  auto fb = Runtime->getFormulaBuilder();
  197|      1|  auto res = dsl::buildSpotMonitorFromDSL(fb);
  198|      1|  return std::make_unique<DSLMonitor>(std::move(Runtime), std::move(res.Monitor), std::move(res.Registry), O);
  199|      1|}
  200|       |
  201|      6|void DSLMonitor::handleEvent(const GenericEvent &event, CheckerContext &C) {
  202|       |  // Framework modeling
  203|      6|  Runtime->handleEvent(event, C);
  204|       |  // SPOT temporal step + report
  205|      6|  if (SpotGraph) {
  206|       |    // Pre-register APs into the SpotGraph's dict (once)
  207|      6|    if (ApVarIds.empty()) {
  208|      4|      for (const auto &kv : Registry.getEvaluators()) {
  209|      4|        const std::string &ap = kv.first;
  210|      4|        int var = SpotGraph->register_ap(ap);
  211|      4|        ApVarIds[ap] = var;
  212|      4|      }
  213|      1|      if (edslDebugEnabled()) {
  214|      1|        llvm::errs() << "[EDSL][SPOT] APs registered: ";
  215|      4|        bool first=true; for (auto &kv : ApVarIds) { if (!first) llvm::errs() << ", "; first=false; llvm::errs() << kv.first << "->" << kv.second; }
                                                                               ^3
  216|      1|        llvm::errs() << "\n";
  217|      1|      }
  218|      1|    }
  219|       |    // Debug: print event
  220|      6|    if (edslDebugEnabled()) {
  221|      6|      llvm::errs() << "[EDSL][SPOT] event: type=" << (int)event.Type
  222|      6|                   << ", fn=" << event.FunctionName
  223|      6|                   << ", sym=" << event.SymbolName << "\n";
  224|      6|    }
  225|       |    // Evaluate APs
  226|      6|    std::set<std::string> trueAPs;
  227|     24|    for (const auto &kv : Registry.getEvaluators()) {
  228|     24|      const std::string &ap = kv.first;
  229|     24|      const auto &eval = kv.second;
  230|     24|      if (eval(event, C)) trueAPs.insert(ap);
                                        ^7
  231|     24|    }
  232|      6|    if (edslDebugEnabled()) {
  233|      6|      llvm::errs() << "[EDSL][SPOT] AP valuation: ";
  234|     24|      for (const auto &kv : Registry.getEvaluators()) {
  235|     24|        const std::string &ap = kv.first;
  236|     24|        bool val = trueAPs.count(ap);
  237|       |        // Try to map AP back to DSL node and function
  238|     60|        int nodeId = -1; for (const auto &m : Registry.getMapping()) if (m.second == ap) { nodeId = m.first; break; }
                                                                                                       ^24
  239|     24|        const LTLFormulaNode *node = Runtime->getFormulaBuilder().getNodeByID(nodeId);
  240|     24|        std::string who = node ? (node->FunctionName.empty() ? node->Binding.SymbolName : node->FunctionName + "(" + node->Binding.SymbolName + ")") : std::string("<synthetic>");
                                               ^18^18                          ^0                         ^18                                                          ^6
  241|     24|        llvm::errs() << ap << "=" << (val?"T":"F") << "[" << who << "] ";
                                                        ^7  ^17
  242|     24|      }
  243|      6|      llvm::errs() << "\n";
  244|      6|    }
  245|       |
  246|       |    // Build valuation cube
  247|      6|    bdd valuation = bddtrue;
  248|     24|    for (const auto &kv : Registry.getEvaluators()) {
  249|     24|      const std::string &ap = kv.first;
  250|     24|      int var = ApVarIds[ap];
  251|     24|      valuation = bdd_and(valuation, trueAPs.count(ap) ? bdd_ithvar(var)
                                                                       ^7        ^7
  252|     24|                                                       : bdd_nithvar(var));
                                                                       ^17        ^17
  253|     24|    }
  254|       |
  255|       |    // Step through transitions
  256|      6|    unsigned ns = SpotGraph->num_states();
  257|      6|    if (CurrentState >= (int)ns) CurrentState = 0;
                                               ^0
  258|      6|    int nextState = CurrentState; bool matched = false;
  259|      6|    for (auto &t : SpotGraph->out(CurrentState)) {
  260|      6|      bdd sat = bdd_restrict(t.cond, valuation);
  261|      6|      if (sat != bddfalse) { nextState = (int)t.dst; matched = true; break; }
  262|      6|    }
  263|      6|    if (matched) {
  264|      6|      if (edslDebugEnabled()) {
  265|      6|        llvm::errs() << "[EDSL][SPOT] state " << CurrentState << " -> " << nextState << "\n";
  266|      6|      }
  267|      6|      CurrentState = nextState;
  268|      6|    } else {
  269|      0|      if (edslDebugEnabled()) {
  270|      0|        llvm::errs() << "[EDSL][SPOT] no transition satisfied from state " << CurrentState << "; temporal violation" << "\n";
  271|      0|      }
  272|       |      // Emit a temporal violation diagnostic
  273|      0|      ExplodedNode *ErrorNode = C.generateErrorNode(C.getState());
  274|      0|      if (ErrorNode) {
  275|      0|        static const BugType BT{Owner, "temporal_violation", "EmbeddedDSLMonitor"};
  276|      0|        std::string msg = "temporal property violated (no transition satisfied)";
  277|      0|        auto R = std::make_unique<PathSensitiveBugReport>(BT, msg, ErrorNode);
  278|      0|        C.emitReport(std::move(R));
  279|      0|      }
  280|      0|    }
  281|      6|  }
  282|      6|}
  283|       |
  284|      0|void DSLMonitor::checkEndAnalysis(ExplodedGraph &G, BugReporter &BR, ExprEngine &Eng) const {
  285|      0|  (void)Eng;
  286|      0|  for (auto I = llvm::GraphTraits<ExplodedGraph *>::nodes_begin(&G),
  287|      0|            E = llvm::GraphTraits<ExplodedGraph *>::nodes_end(&G);
  288|      0|       I != E; ++I) {
  289|      0|    const ExplodedNode *N = *I;
  290|      0|    ProgramStateRef S = N ? N->getState() : nullptr;
  291|      0|    if (!S)
  292|      0|      continue;
  293|      0|    for (auto Sym : S->get<::PendingLeakSet>()) {
  294|      0|      static const BugType BT{Owner, "temporal_violation_end_analysis", "EmbeddedDSLMonitor"};
  295|      0|      ExplodedNode *EN = const_cast<ExplodedNode *>(N);
  296|      0|      std::string internal = "sym_" + std::to_string(Sym->getSymbolID());
  297|      0|      std::string Msg =
  298|      0|          "resource not destroyed before analysis end (violates exactly-once)";
  299|      0|      Msg += " (internal symbol: " + internal + ")";
  300|      0|      Msg += " [reported at EndAnalysis; not all program paths may have been fully explored]";
  301|      0|      auto R = std::make_unique<PathSensitiveBugReport>(BT, Msg, EN);
  302|      0|      R->markInteresting(Sym);
  303|      0|      BR.emitReport(std::move(R));
  304|      0|    }
  305|      0|  }
  306|      0|}
  307|       |
  308|       | 
  309|       |
  310|       |

/Users/efulop/llvm-project/clang/lib/StaticAnalyzer/Checkers/EmbeddedDSLMonitorChecker.cpp:
    1|       |#include "clang/AST/Stmt.h"
    2|       |//===-- EmbeddedDSLMonitorChecker.cpp --------------------------*- C++ -*-===//
    3|       |//
    4|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    5|       |// See https://llvm.org/LICENSE.txt for license information.
    6|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    7|       |//
    8|       |//===----------------------------------------------------------------------===//
    9|       |// Dynamic Embedded DSL for Temporal Logic-based Static Analysis
   10|       |//
   11|       |// This implementation provides a reusable DSL framework where:
   12|       |// 1. Checker callbacks provide generic events (preCall, postCall, deadSymbols)
   13|       |// 2. DSL formulas define monitor automatons for temporal logic properties
   14|       |// 3. ASTMatchers and symbol tracking are handled generically
   15|       |// 4. Properties can be declaratively specified without checker-specific code
   16|       |//
   17|       |// Pure Linear Temporal Logic Formula for malloc/free:
   18|       |//   G( malloc(x) ∧ x ≠ null → F free(x) ∧ G( free(x) → G ¬free(x) ) )
   19|       |//
   20|       |// English: "It is always true that: if a malloc call succeeds, then that memory
   21|       |// must eventually be freed, and once it is freed, it can never be freed again
   22|       |// in any subsequent step."
   23|       |//
   24|       |// The DSL framework supports:
   25|       |//   - Generic event handling (preCall, postCall, deadSymbols)
   26|       |//   - ASTMatchers integration for pattern matching
   27|       |//   - String-based GDM for symbol tracking
   28|       |//   - Declarative property specification
   29|       |//   - Reusable monitor automatons
   30|       |//===----------------------------------------------------------------------===//
   31|       |
   32|       |#include "clang/AST/Decl.h"
   33|       |#include "clang/ASTMatchers/ASTMatchFinder.h"
   34|       |#include "clang/ASTMatchers/ASTMatchers.h"
   35|       |#include "clang/Basic/IdentifierTable.h"
   36|       |#include "clang/StaticAnalyzer/Checkers/BuiltinCheckerRegistration.h"
   37|       |#include "clang/StaticAnalyzer/Checkers/EmbeddedDSLFramework.h"
   38|       |#include "clang/StaticAnalyzer/Core/BugReporter/BugType.h"
   39|       |#include "clang/StaticAnalyzer/Core/Checker.h"
   40|       |#include "clang/StaticAnalyzer/Core/CheckerManager.h"
   41|       |#include "clang/StaticAnalyzer/Core/PathSensitive/CallDescription.h"
   42|       |#include "clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h"
   43|       |#include "clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h"
   44|       |#include "EmbeddedDSLSpot.h"
   45|       |#include <memory>
   46|       |#include <optional>
   47|       |#include <string>
   48|       |#include <unordered_map>
   49|       |#include <vector>
   50|       |
   51|       |using namespace clang;
   52|       |using namespace ento;
   53|       |using namespace ast_matchers;
   54|       |
   55|       |namespace {
   56|       |
   57|       |//===----------------------------------------------------------------------===//
   58|       |// Main Checker Implementation
   59|       |//===----------------------------------------------------------------------===//
   60|       |
   61|       |class EmbeddedDSLMonitorChecker
   62|       |    : public Checker<check::PostCall, check::PreCall, check::DeadSymbols, check::EndFunction, check::EndAnalysis, check::PointerEscape, check::Bind> {
   63|       |
   64|       |  // Unified DSL monitor (framework modeling + SPOT stepping)
   65|       |  std::unique_ptr<dsl::DSLMonitor> Monitor;
   66|       |  // Restrict state tracking to functions referenced in the property (e.g., malloc/free)
   67|       |  mutable std::set<std::string> AllowedFns;
   68|       |
   69|       |  // Generic event generation
   70|       |  dsl::GenericEvent createPostCallEvent(const CallEvent &Call,
   71|       |                                        CheckerContext &C) const;
   72|       |  dsl::GenericEvent createPreCallEvent(const CallEvent &Call,
   73|       |                                       CheckerContext &C) const;
   74|       |  dsl::GenericEvent createDeadSymbolsEvent(SymbolRef Sym,
   75|       |                                           CheckerContext &C) const;
   76|       |
   77|       |public:
   78|      1|  EmbeddedDSLMonitorChecker() {
   79|       |    // Create the property definition and monitor automaton
   80|       |    // Create a generic property with the malloc/free formula
   81|      1|    auto mallocCall = dsl::DSL::Call(
   82|      1|        "malloc", dsl::SymbolBinding(dsl::BindingType::ReturnValue, "x"));
   83|      1|    auto notNull = dsl::DSL::Not(dsl::DSL::Var("x"));
   84|      1|    auto mallocAndNotNull = dsl::DSL::And(mallocCall, dsl::DSL::IsNonNull("x"));
   85|       |
   86|      1|    auto freeCall = dsl::DSL::Call(
   87|      1|        "free", dsl::SymbolBinding(dsl::BindingType::FirstParameter, "x"));
   88|      1|    auto eventuallyFree = dsl::DSL::F(freeCall);
   89|      1|    eventuallyFree->withDiagnostic("Memory leak: allocated memory not freed");
   90|       |
   91|      1|    auto freeImpliesNoMoreFree =
   92|      1|        dsl::DSL::Implies(freeCall, dsl::DSL::G(dsl::DSL::Not(freeCall)));
   93|      1|    freeImpliesNoMoreFree->withDiagnostic(
   94|      1|        "Double free: memory freed multiple times");
   95|       |
   96|      1|    auto globallyNoMoreFree = dsl::DSL::G(freeImpliesNoMoreFree);
   97|      1|    auto eventuallyFreeAndNoMoreFree =
   98|      1|        dsl::DSL::And(eventuallyFree, globallyNoMoreFree);
   99|      1|    auto implication =
  100|      1|        dsl::DSL::Implies(mallocAndNotNull, eventuallyFreeAndNoMoreFree);
  101|      1|    auto globallyImplication = dsl::DSL::G(implication);
  102|      1|    globallyImplication->withDiagnostic("Memory management property violation");
  103|       |
  104|      1|    auto property = std::make_unique<dsl::GenericProperty>(
  105|      1|        "malloc_free_exactly_once",
  106|      1|        "G( malloc(x) ∧ x ≠ null → F free(x) ∧ G( free(x) → G ¬free(x) ) )",
  107|      1|        globallyImplication);
  108|      1|    Monitor = dsl::DSLMonitor::create(std::move(property), this);
  109|       |
  110|       |    // Concise debug: property activation
  111|      1|    auto formulaBuilder = Monitor->getFormulaBuilder();
  112|      1|    llvm::errs() << "EmbeddedDSLMonitor: activating property 'malloc_free_exactly_once'\n";
  113|       |
  114|       |    // Always cache allowed function names for state tracking
  115|      1|    AllowedFns = Monitor->getFormulaBuilder().getFunctionNames();
  116|      1|  }
  117|       |
  118|       |  void checkPostCall(const CallEvent &Call, CheckerContext &C) const;
  119|       |  void checkPreCall(const CallEvent &Call, CheckerContext &C) const;
  120|       |  void checkDeadSymbols(SymbolReaper &SR, CheckerContext &C) const;
  121|       |  void checkEndFunction(const ReturnStmt *RS, CheckerContext &C) const;
  122|       |  void checkEndAnalysis(ExplodedGraph &G, BugReporter &BR, ExprEngine &Eng) const;
  123|       |  ProgramStateRef checkPointerEscape(ProgramStateRef State,
  124|       |                                     const InvalidatedSymbols &Escaped,
  125|       |                                     const CallEvent *Call,
  126|       |                                     PointerEscapeKind Kind) const;
  127|       |  void checkBind(const SVal &location, const SVal &value, const Stmt *StoreE,
  128|       |                 bool isInit, CheckerContext &C) const;
  129|       |};
  130|       |
  131|       |//===----------------------------------------------------------------------===//
  132|       |// Generic Event Generation
  133|       |//===----------------------------------------------------------------------===//
  134|       |
  135|       |dsl::GenericEvent
  136|       |EmbeddedDSLMonitorChecker::createPostCallEvent(const CallEvent &Call,
  137|      2|                                               CheckerContext &C) const {
  138|       |  // Use binding-driven event creation from the monitor
  139|      2|  return Monitor->createBindingDrivenEvent(Call, dsl::EventType::PostCall, C);
  140|      2|}
  141|       |
  142|       |dsl::GenericEvent
  143|       |EmbeddedDSLMonitorChecker::createPreCallEvent(const CallEvent &Call,
  144|      2|                                              CheckerContext &C) const {
  145|       |  // Use binding-driven event creation from the monitor
  146|      2|  return Monitor->createBindingDrivenEvent(Call, dsl::EventType::PreCall, C);
  147|      2|}
  148|       |
  149|       |dsl::GenericEvent
  150|       |EmbeddedDSLMonitorChecker::createDeadSymbolsEvent(SymbolRef Sym,
  151|      0|                                                  CheckerContext &C) const {
  152|      0|  std::string symbolName =
  153|      0|      Sym ? "sym_" + std::to_string(Sym->getSymbolID()) : "unknown";
  154|      0|
  155|      0|  return dsl::GenericEvent(dsl::EventType::DeadSymbols, "", symbolName, Sym,
  156|      0|                           SourceLocation());
  157|      0|}
  158|       |
  159|       |//===----------------------------------------------------------------------===//
  160|       |// Checker Method Implementations
  161|       |//===----------------------------------------------------------------------===//
  162|       |
  163|       |void EmbeddedDSLMonitorChecker::checkPostCall(const CallEvent &Call,
  164|      2|                                              CheckerContext &C) const {
  165|       |  // Only process functions referenced by the property
  166|      2|  const IdentifierInfo *II = Call.getCalleeIdentifier();
  167|      2|  if (!II)
  168|      0|    return;
  169|      2|  std::string Fn = II->getName().str();
  170|      2|  if (AllowedFns.find(Fn) == AllowedFns.end())
  171|      0|    return;
  172|       |
  173|       |  // Generate generic event and let the monitor handle it
  174|      2|  auto event = createPostCallEvent(Call, C);
  175|      2|  if (!event.Symbol)
  176|      0|    return;
  177|       |  // Unified monitor handles modeling + temporal step + diagnostics
  178|      2|  Monitor->handleEvent(event, C);
  179|      2|}
  180|       |
  181|       |void EmbeddedDSLMonitorChecker::checkPreCall(const CallEvent &Call,
  182|      2|                                             CheckerContext &C) const {
  183|       |  // Only process functions referenced by the property
  184|      2|  const IdentifierInfo *II = Call.getCalleeIdentifier();
  185|      2|  if (!II)
  186|      0|    return;
  187|      2|  std::string Fn = II->getName().str();
  188|      2|  if (AllowedFns.find(Fn) == AllowedFns.end())
  189|      0|    return;
  190|       |
  191|       |  // Generate generic event and let the monitor handle it
  192|      2|  auto event = createPreCallEvent(Call, C);
  193|       |  // Unified monitor handles modeling + temporal step
  194|      2|  Monitor->handleEvent(event, C);
  195|      2|}
  196|       |
  197|       |void EmbeddedDSLMonitorChecker::checkDeadSymbols(SymbolReaper &SR,
  198|      8|                                                 CheckerContext &C) const {
  199|       |  // We no longer rely on symbol liveness for leak location placement.
  200|       |  // Leak reporting is finalized in checkEndFunction by inspecting PendingLeakSet.
  201|      8|  (void)SR;
  202|      8|  (void)C;
  203|      8|}
  204|       |
  205|       |void EmbeddedDSLMonitorChecker::checkEndFunction(const ReturnStmt *RS,
  206|      2|                                                 CheckerContext &C) const {
  207|      2|  (void)RS;
  208|       |  // Forward a generic EndFunction event; unified monitor steps and models
  209|      2|  dsl::GenericEvent endEvt(dsl::EventType::EndFunction, "", "", nullptr, SourceLocation());
  210|      2|  Monitor->handleEvent(endEvt, C);
  211|      2|}
  212|       |
  213|       |ProgramStateRef EmbeddedDSLMonitorChecker::checkPointerEscape(
  214|       |    ProgramStateRef State, const InvalidatedSymbols &Escaped,
  215|      2|    const CallEvent *Call, PointerEscapeKind Kind) const {
  216|      2|  (void)Call;
  217|      2|  (void)Kind;
  218|       |  // For every escaped symbol, inform the framework to drop local obligations.
  219|      3|  for (SymbolRef Sym : Escaped) {
  220|      3|    if (!Sym)
  221|      0|      continue;
  222|      3|    dsl::GenericEvent escEvt(dsl::EventType::PointerEscape, "", "sym_" + std::to_string(Sym->getSymbolID()), Sym, SourceLocation());
  223|       |    // Use a dummy CheckerContext-less path? We need a context to transition.
  224|       |    // Here, we can't emit transitions; just mark by removing PendingLeakSet directly via State.
  225|       |    // However, to keep all modeling in framework, we approximate by clearing here too.
  226|       |    // Prefer forwarding via Monitor when context is available; CSA provides only State in this callback.
  227|      3|    State = State->remove<::PendingLeakSet>(Sym);
  228|      3|  }
  229|      2|  return State;
  230|      2|}
  231|       |
  232|       |void EmbeddedDSLMonitorChecker::checkBind(const SVal &location, const SVal &value,
  233|      1|                                          const Stmt *StoreE, bool isInit, CheckerContext &C) const {
  234|       |  // If a symbol is bound into a region, remember it for later nullness checks.
  235|      1|  if (SymbolRef Sym = value.getAsSymbol()) {
  236|      1|    if (const MemRegion *MR = location.getAsRegion()) {
  237|      1|      ProgramStateRef State = C.getState();
  238|      1|      State = State->set<::SymbolToRegionMap>(Sym, MR);
  239|      1|      C.addTransition(State);
  240|      1|    }
  241|      1|  }
  242|      1|}
  243|       |
  244|      1|void EmbeddedDSLMonitorChecker::checkEndAnalysis(ExplodedGraph &G, BugReporter &BR, ExprEngine &Eng) const {
  245|       |  // Safety net: if any symbol still has a pending obligation across final states,
  246|       |  // emit a conservative leak diagnostic. Location quality may be worse.
  247|      1|  for (auto I = llvm::GraphTraits<ExplodedGraph *>::nodes_begin(&G),
  248|      1|            E = llvm::GraphTraits<ExplodedGraph *>::nodes_end(&G);
  249|     30|       I != E; ++I) {
                             ^29
  250|     29|    const ExplodedNode *N = *I;
  251|     29|    ProgramStateRef S = N ? N->getState() : nullptr;
                                                          ^0
  252|     29|    if (!S)
  253|      0|      continue;
  254|     29|    for (auto Sym : S->get<::PendingLeakSet>()) {
  255|       |      // Prefer using the last node for the path; create a report per symbol.
  256|      0|      static const BugType BT{this, "temporal_violation_end_analysis", "EmbeddedDSLMonitor"};
  257|      0|      ExplodedNode *EN = const_cast<ExplodedNode *>(N);
  258|      0|      std::string internal = "sym_" + std::to_string(Sym->getSymbolID());
  259|      0|      std::string Msg =
  260|      0|          "resource not destroyed before analysis end (violates exactly-once)";
  261|      0|      Msg += " (internal symbol: " + internal + ")";
  262|      0|      Msg += " [reported at EndAnalysis; not all program paths may have been fully explored]";
  263|      0|      auto R = std::make_unique<PathSensitiveBugReport>(BT, Msg, EN);
  264|      0|      R->markInteresting(Sym);
  265|      0|      BR.emitReport(std::move(R));
  266|      0|    }
  267|     29|  }
  268|      1|}
  269|       |
  270|       |} // namespace
  271|       |
  272|       |//===----------------------------------------------------------------------===//
  273|       |// Checker Registration
  274|       |//===----------------------------------------------------------------------===//
  275|       |
  276|      1|void ento::registerEmbeddedDSLMonitor(CheckerManager &mgr) {
  277|      1|  mgr.registerChecker<EmbeddedDSLMonitorChecker>();
  278|      1|}
  279|       |
  280|      2|bool ento::shouldRegisterEmbeddedDSLMonitor(const CheckerManager &mgr) {
  281|      2|  return true;
  282|      2|}

